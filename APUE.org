#+SETUPFILE: ~/Documents/style.setup
#+STARTUP: inlineimages:png
#+OPTIONS: num:nil
#+LATEX_HEADER: \usepackage{ulem}
#+LATEX_HEADER: \usepackage{ctex}
#+LaTeX_HEADER: \sectionfont{\normalfont\scshape}
#+LaTeX_HEADER: \subsectionfont{\normalfont\itshape}
#+AUTHOR: whiothes
#+title: Advanced Programming in the Unix Environment

* Advanced Programming in the Unix Environment [47%]
** DONE Chapter 1. UNIX System Overview [12/12]
   CLOSED: [2019-11-08 Fri 00:38]
*** DONE 1.1 Introduction
*** DONE 1.2 UNIX Architecture
*** DONE 1.3 Logging in
    - Login Name
*** DONE 1.4 Files and Directories
    - File System
    - Pathname
      - Example \\
        #+NAME: Figure 1.3 List all the files in a directory
        #+begin_src C
          #include <dirent.h>
          #include "apue.h"

          int main(int argc, char *argv[]) {
            DIR *dp;
            struct dirent *dirp;

            if (argc != 2) {
              err_quit("usage: ls directory_name")}

            if ((dp = opendir(argv[1])) == NULL) {
              err_sys("can't open %s", argv[1]);
            }
            while ((dirp = readdir(dp)) != NULL) {
              printf("%s\n", dirp->d_name);
            }

            closedir(dp);
            exit(0);
          }
        #+end_src

        #+RESULTS: Figure 1.3 List all the files in a directory

*** DONE 1.5 Input and Output - File Descriptors
    - Standard Input, Standard Output, and Standard Error
    - Unbuffered I/O
      - Example \\
        #+caption: Figure 1.4 Copy standard input to standard output
        #+include: "Chapter01/mycp.c" src c

    - Standard I/O
      - Example \\
        #+caption: Figure 1.5 Copy standard input to standard output, using standard I/O
        #+include: "Chapter01/getcputc.c" src c
*** DONE 1.6 Programs and Processes
    - Program
    - Proceses and Process ID
      - Example \\
        #+caption: Figure 1.6 Print the process ID
        #+include: "Chapter01/uidgid.c" src c
    - Process Control
      - Example \\
        #+caption: Figure 1.7 Read commands from standard input and execute them
        #+include: "Chapter01/shell1.c" src c
*** DONE 1.7 Error Handling
    - Example \\
      #+caption: Figure 1.8 Demonstrate strerror and perror
      #+include: "Chapter01/testerror.c" src c
*** DONE 1.8 User identification
    - User ID
    - Group ID
      - Example \\
        #+caption: Figure 1.9 Print user ID and group ID
        #+include: "Chapter01/uidgid.c" src c
    - Supplementary Group IDs
*** DONE 1.9 Signals
    Process choices:
    1.  Ignore
    2.  default action
    3.  provide call function (catch signal)


    - Example \\
      #+caption: Figure 1.10 Read commands from standard input and execute them
      #+include: "Chapter01/shell2.c" src c
*** DONE 1.10 Time Values
    1.  Calendar time.
    2.  Process time.
       - Clock time
       - User CPU time
       - System CPU time
*** DONE 1.11 System calls and Library Functions
    - Concepts:
      - System calls: \\
        - Can be learned with ~man 2~ (Section 2 of /Unix Programmer's Mannual/)
      - Library Functions:
        - Can be learned with ~man 3~ for *general-purpose* (Section 3 of /Unix Programmer's Mannual/)
        - These functions aren’t entry points into the kernel, although they may invoke one or more of the kernel’s system calls
    - Distinction:
      - the system calls usually cannot be replaced
      - UNIX System provides to determine the current time and date
*** DONE 1.12 Summary
    *Exercises*
    - 1.1
    - 1.2  53268 50922 was occupied
    - 1.3  strerror: int, value transfer, cannnot be changed, global errno cannnot be forecast
           perror: pointer, can be changed the value point to, const set constant
    - 1.4  2038, 2^{31}/(60*60*24*365)+1970
           change time_t to u_64_t
           recompile the program
    - 1.5  2^{31}/(60*60*24*100)=248.551348 days
** DONE Chapter 2. UNIX Standardization and Implementations [10/10]
*** DONE 2.1 Introduction
*** DONE 2.2 UNIX Standardization
**** DONE ISO C
**** DONE IEEE POSIX
**** DONE The Single UNIX Specification
     - Encryption: denoted by ~_XOPEN_CRYPE~
     - Real-time: denoted by ~_XOPEN_REALTIME~
     - Advanced real-time
     - Real-time threads: denoted by ~_XOPEN_REALTIME_THREADS~
     - Advanced real-time threads
**** DONE FIPS
*** DONE 2.3 UNIX System Implementations
**** DONE SVR4
**** DONE 2.3.1 4.4BSD
**** DONE 2.3.2 FreeBSD
**** DONE Linux
**** DONE Mac OS X
**** DONE SOlaris
**** DONE Others
     - AIX, IBMUNIX
     - HP-UX, HP
     - IRIX, Silicon Graphics
     - Unix Ware, SVR4 distribution
*** DONE 2.4 Relationship of Standards and Implementations
*** DONE 2.5 Limits
    1.  Comipile-time limits
    2.  Runtime limits
**** DONE ISO C Limits
**** DONE POSIX Limits
     1.  Numerical limits: ~LONG_BIT~, ~SSIZE_MAX~, and ~WORD_BIT~
     2.  Minimum value：
     3.  Maximum value: ~_POSIX_CLOCKRES_MIN~
     4.  Runtime increasable values: ~CHARCLASS_NAME_MAX~, ~COLL_WEIGHTS_MAX~, ~LINE_MAX~, ~NGROUPS_MAX~, and ~RE_DUP_MAX~
     5.  Runtime invariant values;
     6.  Other invariant values: ~NL_ARGMAX~, ~NL_MSGMAX~, ~NL_SETMAX~, and ~NL_TEXTMAX~;
     7.  Pathname variables values: ~FIFLESIZEBITS~, ~LINK_MAX~, ~MAX_CANON~, ~MAX_INPUT~, ~NAME_MAX~, ~PATH_MAX~, ~PIPE_BUF~, and ~SYMLINK_MAX~
**** DONE XSI Limits
     1.  Minimum values:
     2.  Runtime invariant values, possibly indeterminate: *IOV_MAX* and *PAGE_SIZE*
**** DONE ~sysconf~, ~pathconf~, and ~fpathconf~ Functions
     #+caption: Figure 2.13 Build C program to print all supported configuration limits
     #+include: "Chapter02/makeconf.awk" src c
**** DONE Indeterminate Runtime Limits
     1.
     #+caption: pathalloc
     #+include: "lib/pathalloc.c" src c
     2.
     #+caption: openmax
     #+include: "lib/openmax.c" src c
*** DONE 2.6 Options
    1.  Compile-time options are defined in ~<unistd.h>~
    2.  Runtime options are not associated with a file or a directory are idnetified with the ~sysconf~ function
    3.  Runtime options that are associated with a file or a directory are discovered by calling either the ~pathconf~ or the ~fpathconf~ function
*** DONE 2.7 Features Test Macros
    ~cc -D_POSIX_C_SOURCE=200809L code.c~
*** DONE 2.8 Primitive System Data Types
    The header ~<sys/types.h>~ defines some implementation-dependent data types, called the /primitive system data types/.
*** DONE 2.9 Differences Between Standards
*** DONE 2.10 Summary
    *Exercises*
    - 2.1  #ifndef ... #define ... #endif
    - 2.2  ~u_long, ushort, uint, u_quad_t, quad_t, qaddr_t, daddr_t, fixpt_t~
    - 2.3
      #+caption: OPEN_MAX exercise
      #+include: "Chapter02/ex02.c" src c
** DONE Chapter 3. File I/O [17/17]
   CLOSED: [2019-11-08 Fri 00:38]
   :PROPERTIES:
   :EXPORT_FILE_NAME: ./build/./build/./build/Chapter_3._File_I/O
   :END:
*** DONE 3.1 Introduction
*** DONE 3.2 File Descriptors
    To the kernel, all open file are referred to by file descriptors.
    - 0: stdin
    - 1: stdout
    - 2: stderr
*** DONE 3.3 ~open~ and ~openat~ Functions
    ~man 2 open~
*** DONE 3.4 ~creat~ Function
    ~man 2 creat~
*** DONE 3.5 ~close~ Function
    ~man 2 close~
*** DONE 3.6 ~lseek~ Function
    ~man 2 lseek~
    - Example \\
      #+caption: Figure 3.1 Test whether standard input is capable of seeking
      #+include: "Chapter03/seek.c" src c \\
    #+caption: Figure 3.2 Create a file with a hole in it
    #+include: "Chapter03/hole.c" src c
*** DONE 3.7 ~read~ Function
    ~man 2 read~
*** DONE 3.8 ~write~ Function
    ~man 2 write~
*** DONE 3.9 I/O Efficiency
    #+caption: Figure 3.5 Copy standard input to standard output
    #+include: "Chapter03/fig3.5.c" src c
*** DONE 3.10 File Sharing
    1.  Every process has an entry in the process table.
    2.  The kernel maintains a file table for all open files.
    3.  Each open file(or device) has a v-node structure that contains information about the type of file \\
       and pointers to functions that operate on the file;
*** DONE 3.11 Atomic Operations
    - Appending to a File
    - ~pread~ and ~pwrite~ Functions
      Calling pread is equivalent to calling lseek followed by a call to read, with the following exceptions.
      - There is no way to interrupt the two operations that occur when we call pread.
      - The current file offset is not updated.

    - Creating a File
      /atomic operation/ refers to an operation that might be composed of multiple steps
*** DONE 3.12 ~dup~ and ~dup2~ Functions
    ~man 2 dup~
    - ~dup(fd)~ ~ =fcntl(fd, F_DUPFD, 0)~
    - ~dup2(fd, fd2)= = =close(fd2); fcntl(fd, F_DUPFD, fd2);~ \\
    Differences:
    - dup2 is an atomic operation, whereas the alternate form involves two function calls.
    - errno differences
*** DONE 3.13 ~sync~, ~fsync~ and ~fdatasync~ Functions
    ~man 2 sync~
*** DONE 3.14 ~fcntl~ Function
    ~man 2 fcntl~
    The ~fcntl~ function is used for five different purposes.
    1.  Duplicate an existing descriptor (/cmd/ = =F_DUPFD= or =F_DUPFD_CLOEXEC=)
    2.  Get/set file descriptor flags (/cmd/ = =F_GETFD= or =F_SETFD=)
    3.  Get/set file status flags (/cmd/ = =F_GETFL= or =F_SETFL=)
    4.  Get/set asynchronous I/O ownership (/cmd/ = =F_GETOWN= or =F_SETOWN=)
    5.  Get/set record locks (/cmd/ = =F_GETLK=, =F_SETLK=, or =F_SETLKW=)


    - Example \\
      #+caption: Figure 3.11 Print file flags for specified descriptor
      #+include: "Chapter03/fileflags.c" src c \\
    #+caption: Figure 3.12 Turn on one or more of the file status flags for a descriptor
    #+include: "Chapter03/setfl.c" src c
*** DONE 3.15 ~ioctl~ Function
    =man 2 ioctl=
*** DONE 3.16 ~/dev/fd~
*** DONE 3.17 Summary
    *Exercises*
    - 3.1  All disk I/O need to via buffer block. \\
      ~read/write~ always be buffered via kernel automatically, unbuffered only means user process;
    - 3.2
      #+include: "Chapter03/mydup2.c" src c
    - 3.3  F_SETFD: affect fd1 *file descriptor* \\
      F_SETFL: affect fd1 and fd2 *file table*
    - 3.4  without =if (fd > 2)=, there are 4 descriptors pointer to file, otherwise , there will be 3
    - 3.5  =./a.out > outfile 2>&1=: stdout => outfile, stderr => stdout => outfile
      =./a.out 2>&1 > outfile=: stderr => stdout, stdout => outfile \\
    - 3.6
      #+include: "Chapter03/ex06.c" src c, can be read random, but cannot replace existing data;
** DONE Chapter 4. System Data Files and Information [26/26]
   CLOSED: [2019-11-08 Fri 00:38]
*** DONE 4.1 Introduction
*** DONE 4.2 ~stat~, ~fstat~, ~fstatat~, and ~lstat~ Functions
    =man 2 stat=
*** DONE 4.3 File Types
    1.  Regular file.
       There is no distinction to the UNIX kernel whether this data is text or binary.
    2.  Directory file.
    3.  Block special file.
    4.  Character special file.
       providing unbuffered I/O access.
    5.  FIFO.
    6.  Socket
    7.  Symbolic link.


    - Example \\
      #+caption: Figure 4.3 Print type of file for each command-line argument
      #+include: "Chapter04/filetype.c" src c
*** DONE 4.4 Set-User-ID and Set-Group-ID
    | IDs                     | using for                              |
    |-------------------------+----------------------------------------|
    | real user ID            | who we really are                      |
    | real group ID           |                                        |
    |-------------------------+----------------------------------------|
    | effective user ID       |                                        |
    | effective group ID      | used for file access permission checks |
    | supplementary group IDs |                                        |
    |-------------------------+----------------------------------------|
    | save set-user-ID        | saved by exec functions                |
    | save set-group-ID       |                                        |
*** DONE 4.5 File Access Permissions
    | st_mode mask | Meaning       |
    |--------------+---------------|
    | S_IRUSR      | user-read     |
    | S_IWUSR      | user-write    |
    | S_IXUSR      | user-execute  |
    |--------------+---------------|
    | S_IRGRP      | group-read    |
    | S_IWGRP      | group-write   |
    | S_IXGRP      | group-execute |
    |--------------+---------------|
    | S_IROTH      | other-read    |
    | S_IWOTH      | other-write   |
    | S_IXOTH      | other-execute |
*** DONE 4.6 Ownership of New Files and Directories
*** DONE ~access~ and ~faccessat~ Functions
    =man 2 access=
    - Example \\
      #+caption: Figure 4.8 Example of access function
      #+include: "Chapter04/access.c" src c
*** DONE ~umask~ Function
    =man 2 umask=
    - Example \\
      #+caption: Figure 4.9 Example of umask function
      #+include: "Chapter04/umask.c" src c
*** DONE ~chmod~, ~fchmod~, and ~fchmodat~ Functions
    =man 2 chmod=
    - Example \\
      #+caption: Figure 4.12 Example of chmod function
      #+include: "Chapter04/changemod.c" src c
*** DONE Sticky Bit
    If it was set for an executable program file, then the first time the program was executed, \\
    a copy of the program’s text was saved in the swap area when the process terminated
*** DONE ~chown~, ~fchown~, ~fchownat~, and ~lchown~ Functions
    =man 2 chown=
*** DONE File Size
    =struct stat.st_size=
*** DONE File Truncation
    =man 2 truncate=
*** DONE File Systems
    - Only when the link count goes to 0 can the file be deleted. \\
      =struct stat.st_nlink=
    - The other type of link is called a symbolic link. With a symbolic link, the actual contents of the file—the data blocks—store the name of the file that the symbolic link points to.
    - The i-node contains all the information about the file. \\
      Most of the information in the stat structure is obtained from the i-node, exclude *filename* and *i-node* number.
    - a directory entry can’t refer to an i-node in a different file system.
    - When renaming a file without changing file systems, the actual contents of the file need not be moved—all that needs to be done is to add a new directory entry that points to the existing i-node and then unlink the old directory entry.
*** DONE ~link~, ~linkat~, ~unlink~, ~unlinkat~, and ~remove~ Functions
    =man 2 link=
    - Example \\
      #+caption: Figure 4.16 Open a file and then unlink it
      #+include: "Chapter04/unlink.c" src c
*** DONE ~rename~ and ~renameat~ Functions
    =man 2 rename=
    1.  If oldname specifies a file that is not a directory, then we are renaming a file or a symbolic link.
    2.  If oldname specifies a directory, then we are renaming a directory.
    3.  If either oldname or newname refers to a symbolic link, then the link itself is processed, not the file to which it resolves.
    4.  We can’t rename dot or dot-dot.
    5.  As a special case, if oldname and newname refer to the same file, the function returns successfully without changing anything.
*** DONE Symbolic Links
    - Hard links normally require that the link and the file reside in the same file system.
    - Only the superuser can create a hard link to a directory (when supported by the underlying file system).
*** DONE Creating and Reading Symbolic Links
    =man 2 symlink=
    =man 2 readlink=
*** DONE File Times
*** DONE ~futimens~, ~utimensat~, and ~utimes~ Functions
    POSIX.1
    =man 2 futimens=
    XSI
    =man 2 utimes=
    - Example \\
      #+caption: Figure 4.21 Example of futimens function
      #+include: "Chapter04/futimens.c" src c
*** DONE ~mkdir~, ~mkdirat~, and ~rmdir~ Functions
    Creat:
    =man 2 mkdir=
    Remove:
    =man 2 rmdir=
*** DONE Reading Directories
    =man 3 opendir=
    - Example \\
      [[/Users/zhoush/Private/Notes/books/c/APUE/Chapter04/ftw.c][Figure 4.22 Recursively descend a directory hierarchy, counting file types]]
*** DONE ~chidr~, ~fchdir~ and ~getcwd~ Functions
    =man 2 chdir=
    - Example \\
      #+caption: Figure 4.23 Example of chdir function
      #+include: "Chapter04/chdir.c" src c
    =man 3 getcwd=
    - Example \\
      #+caption: Figure 4.24 Example of getcwd function
      #+include: "Chapter04/getcwd.c" src c
*** DONE Device Special Files
    - Example \\
      #+caption: Figure 4.25 Print st_dev and st_rdev values
      #+include: "Chapter04/devrdev.c" src c
*** DONE Summary of File Access Permission Bits
    S_IRWXU = S_IRUSR | S_IWUSR | S_IXUSR
    S_IRWXG = S_IRGRP | S_IWGRP | S_IXGRP
    S_IRWXO = S_IROTH | S_IWOTH | S_IXOTH
*** DONE Summary
    *Exercises*
    - 4.1
      #+include: "Chapter04/exercises/ex1.c" src c
      before modification: symbolic link
      after  modification: regular
    - 4.2  default permissions: =----------=
    - 4.3  ~cat~ get : Permission denied
    - 4.4  nothing changed.
    - 4.5  directory always shoud be entries for . and ..
      the size of symbolic link should be the size of the file contained in.
    - 4.6
      #+include: "Chapter04/exercises/ex6.c" src c
    - 4.7  default access permissions are different
    - 4.8  ~du~ check the file/directory/path space instead of disk , and may need path permissions.
    - 4.9  it's not the last link to the file.
    - 4.10  recursive depth number
    - 4.11
      #+include: "Chapter04/exercises/ex11.c" src c
    - 4.12  FTP
    - 4.13  ~stat~ first, set timespec array to current time that you expect not change, and the other to the value you want.
    - 4.14  access time is the last read time \\
      modify time is last received
    - 4.15  The change time isn't stored because, even if it was stored, you wouldn't be able to set it to the original time. You cannot cheat the change time, it is always based on when the inode data was actually changed.
      \\
      Depending on the utility (tar or cpio), you can tell it to keep the original access and/or modify times. For example, tar by default maintains the original modify time but you can use the -m switch to set it to extraction time. The access time is always set to extraction time.
    - 4.16
      #+include: "Chapter04/exercises/ex16.c" src c \\
    - 4.17
      #+include: "Chapter04/exercises/ex17.c" src c \\
      =unlink: Operation not permitted=
** DONE Chapter 5. Standard I/O Library [16/16]
   CLOSED: [2019-11-08 Fri 00:38]
*** DONE 5.1 Introduction
    This library is specified by the ISO C standard because it has been implemented on many operating systems other than the UNIX System.
*** DONE 5.2 Streams and FILE Objects
    =man 3 fwide=
*** DONE 5.3 Standard Input, Standard Output and Standard Error
    ~STDIN_FILENO~, ~STDOUT_FILENO~, ~STDERR_FILENO~
*** DONE 5.4 Buffering
    Three types of buffering are provided:
    1.  Fully buffered. \\
       In this case, actual I/O takes place when the standard I/O buffer is filled.
    2.  Line buffered. \\
       In this case, the standard I/O library performs I/O when a newline character is encountered on input or output.
    3.  Unbuffered. \\

    ISO C requires the following buffering characteristics:
    - Standard input and standard output are fully buffered, if and only if they do not refer to an interactive device.
    - Standard error is never fully buffered.

    Most implementations default to the following types of buffering:
    - Standard error is always unbuffered.
    - All other streams are line buffered if they refer to a terminal device; otherwise, they are fully buffered.


    =man 3 setbuf=
    =man 3 fflush=
*** DONE 5.5 Opening a Stream
    =man 3 fopen=
    =man 3 fclose=
*** DONE 5.6 Reading and Writing a Stream
    Three types of unformatted I/O:
    1.  Character-at-a-time I/O.
    2.  Line-at-a-time I/O.
    3.  Direct I/O.
5.7 **** DONE Input Functions
     =man 3 getc=
     1.  The argument to getc should not be an expression with side effects, because it could be evaluated more than once.
     2.  Since fgetc is guaranteed to be a function, we can take its address. This allows us to pass the address of fgetc as an argument to another function.
     3.  Calls to fgetc probably take longer than calls to getc, as it usually takes more time to call a function.


     In most implementations, two flags are maintained for each stream in the FILE object:
     =man 3 ferror=
     - An error flag
     - An end-of file flagp


     After reading from a stream, we can push back characters by calling ~ungetc~.
5.8 **** DONE Output Functions
     =man 3 putc=
*** DONE 5.9 Line-at-a-Time I/O
    =man fgets=
*** DONE 5.10 Standard I/O Efficiency
    #+caption: Figure 5.4 Copy standard input to output using getc and putc
    #+include: "Chapter05/cpio.c" src c \\
    #+caption: Figure 5.5 Copy standard input to output using fgets and fputs
    #+include: "Chapter05/cpio_1.c" src c
*** DONE 5.11 Binary I/O
    =man fread=
*** DONE 5.12 Positioning a Stream
    Three way to position a standard I/O stream:
    1.  ~ftell~ and ~fseek~
    2.  ~ftello~ and ~fseeko~
    3.  ~fgetpos~ and ~fsetpos~


    When porting applications to non-UNIX systems, use fgetpos and fsetpos.
    #+begin_src c
      #include <stdio.h>

      int
      fgetpos(FILE *restrict stream, fpos_t *restrict pos);

      int
      fseek(FILE *stream, long offset, int whence);

      int
      fseeko(FILE *stream, off_t offset, int whence);

      int
      fsetpos(FILE *stream, const fpos_t *pos);

      long
      ftell(FILE *stream);

      off_t
      ftello(FILE *stream);

      void
      rewind(FILE *stream);
    #+end_src
*** DONE 5.13 Formated I/O
    =man 3 printf=

    #+caption: Figure 5.7 The flags component of a conversion specification
    | Flag    | Description                                                                           |
    |---------+---------------------------------------------------------------------------------------|
    | /       | <>                                                                                    |
    | '       | [[file:Chapter05/formatted.c::printf("\nthousands%20grouping:\n");][(apostrophe) format integer with thousands grouping characters]]                        |
    | -       | [[file:Chapter05/formatted.c::printf("\nleft-justify:\n");][left justify]]                                                                          |
    | +       | [[file:Chapter05/formatted.c::printf("\nsigned%20decimal:\n");][always display sign of a signed conversion]]                                            |
    | (space) | [[file:Chapter05/formatted.c::printf("\nspace%20prefix:\n");][prefix by a space if no sign is generated]]                                             |
    | \#      | [[file:Chapter05/formatted.c::printf("\nalternative%20form:\n");][convert using alternative form(include 0x prefix for hexadecimal format, for example)]] |
    | 0       | [[file:Chapter05/formatted.c::printf("\nprefix%20zero:\n");][prefix with leading zeros instead of padding with spaces]]                              |

    #+caption: Figure 5.8 The lenth modifier component of a conversion specification
    | Length modifer | Description                               |
    |----------------+-------------------------------------------|
    | /              | <>                                        |
    | hh             | signed or unsigned char                   |
    | h              | sigend or unsigned short                  |
    | l              | signed or unsigned long or wide character |
    | ll             | signed or unsigned long long              |
    | j              | inmax_t or uintmax_t                      |
    | z              | size_t                                    |
    | t              | ptrdiff_t                                 |
    | L              | long double                               |

    #+caption: Figure 5.9 The conversion type component of a conversion specification
    | Conversion type | Description                                                                               |
    |-----------------+-------------------------------------------------------------------------------------------|
    | /               | <>                                                                                        |
    | d,i             | [[file:Chapter05/formatted.c::printf("\nsigned%20decimal:\n");][signed decimal]]                                                                            |
    | o               | [[file:Chapter05/formatted.c::printf("\nalternative%20form:\n");][unsigned octal]]                                                                            |
    | u               | [[file:Chapter05/formatted.c::printf("\nunsigned%20decimal:\n");][unsigned decimal]]                                                                          |
    | x,X             | [[file:Chapter05/formatted.c::printf("\nunsigned%20hexadecimal:\n");][unsigned hexadecimal]]                                                                      |
    | f,F             | [[file:Chapter05/formatted.c::printf("\ndouble%20%EF%AC%82oating-point%20number:\n");][double floating-point number]]                                                              |
    | e,E             | [[file:Chapter05/formatted.c::printf("\nexponential%20format:\n");][double floating-point number in exponential format]]                                        |
    | g,G             | [[file:Chapter05/formatted.c::printf("\ninterpreted:\n");][interpreted as f, F, e, or E, depending on value converted]]                                |
    | a,A             | [[file:Chapter05/formatted.c::printf("\ndouble%20in%20hexadecimal:\n");][double ﬂoating-point number in hexadecimal exponential format]]                             |
    | c               | character (with 1 length modifier, wide character)                                        |
    | s               | string(with 1 length modifier, wide character string)                                     |
    | p               | pointer to a void                                                                         |
    | n               | pointer to a signed integer into which is written the number of characters written so far |
    | %               | a % character                                                                             |
    | C               | wide chracter(XSI option, equivalent to lc)                                               |
    | S               | wide chracter string(XSI option, equivalent to ls)                                        |


    *Formatted Input*
    =man 3 scanf=
    #+caption: Figure 5.9 The conversion type component of a conversion specification
    | Conversion type | Description                                                                               |
    |-----------------+-------------------------------------------------------------------------------------------|
    | /               | <>                                                                                        |
    | d               | signed decimal, base 10                                                                   |
    | i               | signed decimal, base determined by format of input                                        |
    | o               | unsigned octal(input optionally signed)                                                   |
    | u               | unsigned decimal, base 10(input optionally signed)                                        |
    | x,X             | unsigned hexadecimal(input optionally signed)                                             |
    | a,A,e,E,f,F,g,G | floating-point number                                                                     |
    | c               | character (with 1 length modifier, wide character)                                        |
    | s               | string(with 1 length modifier, wide character string)                                     |
    | [               | mathches a sequence of listed characters, ending with ]                                   |
    | [^              | mathches all characters except the ones listed, ending with ]                             |
    | p               | pointer to a void                                                                         |
    | n               | pointer to a signed integer into which is written the number of characters written so far |
    | %               | a % character                                                                             |
    | C               | wide chracter(XSI option, equivalent to lc)                                               |
    | S               | wide chracter string(XSI option, equivalent to ls)                                        |

    ***
*** DONE 5.14 Implementation Details
    =man 3 fileno=

    - Example \\
      #+caption: Figure 5.11 Print buffering for various standard I/O streams
      #+include: "Chapter05/print.c" src c
*** DONE 5.15 Temporary Files
    =man 3 tmpnam=
    - Example \\
      #+caption: Figure 5.12 Demonstrate tmpnam and tmpfile functions
      #+include: "Chapter05/tmpnam.c" src c

    =man 3 mkdtemp=
    - Example \\
      #+caption: Figure 5.13 Demonstrate mkstemp function
      #+include: "Chapter05/mkdtemp.c" src c
*** DONE 5.16 Memory Streams
    =man 3 fmemopen=
    - Example \\
      #+caption: Figure 5.15 Investigate memory stream write behavior
      #+include: "Chapter05/memopen.c" src c \\
    *linux* result:
    #+begin_quote
    initial buffer contents: \\
    before flush: \\
    after fflush: hello, world \\
    len of string in buf = 12 \\
    after fseek: bbbbbbbbbbbbhello, world \\
    len of string in buf = 24 \\
    after fclose: hello, worldcccccccccccccccccccccccccccccccccc \\
    len of string in buf = 46
    #+end_quote

    The other two functions:
    =man open_memstream=
*** DONE 5.17 Alternatives to Standard I/O
    The standard I/O library is not perfect. some in the basic design, but most in the various implementations.
*** DONE 5.18 Summary
    *Exercises*
    - 3.1
      #+include: "Chapter05/exercises/ex1.c" src c
    - 3.2
      #+include: "Chapter05/exercises/ex2.c" src c \\
      execute ~fgets~ and ~fputs~ more than 1 times;
    - 3.3  print nothing
    - 3.4  This is a common error. The return value from getc and getchar is an int, not a char. EOF is often defined to be −1, so if the system uses signed characters, the code normally works
    - 3.5  call ~fflush~ first
    - 3.6  stdin and stdout are both line buffered. fgets will fflush automatically
    - 3.7
      #+include: "Chapter05/exercises/funopen-fmemopen.c" src c
** DONE Chapter 6. System Data Files and Information [11/11]
   CLOSED: [2019-11-08 Fri 00:38]
*** DONE 6.1 introduction
*** DONE 6.2 Password File
    =man getpwuid=
*** DONE 6.3 Shadow Passwords
    *On Linux 3.2.0 and Solaris 10,*
    =man getspnam=
    *On FreeBSD 8.0 and Mac OS X 10.6.8, there is no shadow password structure*
*** DONE 6.4 Group File
    =man getgrgid=
*** DONE 6.5 Supplementary Group Ids
    =man getgroups= \\
    - Example \\
      #+caption: Example for get groups' info
      #+include: "Chapter06/getgropus.c" src c
*** DONE 6.6 Implementation Differences
*** DONE 6.7 Other Data Files
    at least three functions:
    1.  A get function that reads the next record, opening the file if necessary.
    2.  A set function that opens the file, if not already open, and rewinds the file.
    3.  An end entry that closes the data file.
*** DONE 6.8 Login Accounting
    #+begin_src c
      struct utmp {
        char ut_line[8]; /* tty line: "ttyh0", "ttyd0", "ttyp0", ... */
        char ut_name[8]; /* login name */
        long ut_time; /* seconds since Epoch */
      };
    #+end_src
*** DONE 6.9 System Identification
    =man 3 uname=
    =man 3 gethostname=
*** DONE 6.10 Time and Date Routines
    =man 3 time=
    =man 3 clock_gettime=
    =man 3 gmtime=
    =man 3 strftime=
    - Example \\
      #+caption: Figure 6.11 Using the strftime function
      #+include: "Chapter06/strftime.c" src c \\
    =man 3 strptim=
*** DONE 6.11 Summary
    *Exercises*
    - 6.1  On Mac OS, I can't get it \\
      On Linux, use ~getsnam~ group functions
    - 6.2
      #+include: "Chapter06/exercises/getspnam.c" src c
    - 6.3
      #+include: "Chapter06/exercises/uname.c" src c, equivalent
    - 6.4 32-bit time: =1970 + (2^{31}/60/60/24/365)= \\
      after pass : =1970 - (2^{31}/60/60/24/365)=
    - 6.5
      #+include: "Chapter06/exercises/time.c" src c
** DONE Chapter 7. Process Environment [11/11]
   CLOSED: [2019-11-08 Fri 00:38]
*** DONE 7.1 Introduction
*** DONE 7.2 main Function
    #+begin_src C
      int main(int argc, char *argv[]);
    #+end_src
*** DONE 7.3 Process Termination
    There are eight ways for a process to terminate.
    Normal termination occurs in five ways:
    1.  Return from main
    2.  Calling ~exit~
    3.  Calling ~_exit~ or ~_Exit~
    4.  Return of the last thread from its start routine (Section 11.5)
    5.  Calling pthread_exit (Section 11.5) from the last thread


    Abnormal termination occurs in three ways
    1.  Calling abort
    2.  Receipt of a signal
    3.  Response of the last thread to a cancellation request
**** DONE Exit Functions
     =man 3 exit=
     =man 2 _exit=
     #+begin_src c
       #include <stdio.h>
       void exit(int status);
       // 1. call the functions registered with atexit(3) function, in the reverse order of their registration
       // 2. Flush all open output streams
       // 3. close all open streams
       // 4. unlink all files created with the tmpfile functions

       void _Exit(int status);
       // terminates without calling functions registered with atexit(3),
       // may or my not perform the other actions listed

       #include <unistd.h>
       void _exit(int status);
       // The _exit() function terminates a process, with the following consequences:
       // o   All of the descriptors that were open in the calling process are closed.  This may entail delays; for example, waiting for output to drain.  A process in this state may not be
       //     killed, as it is already dying.
       //
       // o   If the parent process of the calling process has an outstanding wait call or catches the SIGCHLD signal, it is notified of the calling process's termination; the status is set as
       //     defined by wait(2).
       //
       // o   The parent process-ID of all of the calling process's existing child processes are set to 1; the initialization process (see the DEFINITIONS section of intro(2)) inherits each of
       //     these processes.
       //
       // o   If the termination of the process causes any process group to become orphaned (usually because the parents of all members of the group have now exited; see ``orphaned process
       //     group'' in intro(2)), and if any member of the orphaned group is stopped, the SIGHUP signal and the SIGCONT signal are sent to all members of the newly-orphaned process group.
       //
       // o   If the process is a controlling process (see intro(2)), the SIGHUP signal is sent to the foreground process group of the controlling terminal.  All current access to the control-
       //     ling terminal is revoked.
     #+end_src
     ~_exit~ does not perform any ﬂushing of standard I/O buffers.
     - Example \\
       #+begin_src c

       #+end_src
       #+caption: Figure 7.1 Classic C program
       #+include: "Chapter07/hello.c" src c
**** DONE ~atexit~ Function
     =man 3 atexit=
     The ~exit~ function calls these functions in reverse order of their registration.

     - Example \\
       #+caption: Figure 7.3 Example of exit handlers
       #+include: "Chapter07/atexit.c" src c
**** DONE Commond-Line Arguments
     - Example \\
       #+caption: Figure 7.4 Echo all command-line arguments to standard output
       #+include: "Chapter07/echoarg.c" src c
*** DONE 7.5 Environment List

    #+begin_src c
      extern char **environ;
    #+end_src
*** DONE 7.6 Memory Layout of a C Program
    Historically, a C program has been composed of the following pieces:
    - Text segment: consisting of the machine instructions that the CPU executes.
    - Initilized data segment, usually called simply the data segment, \\
      containing variables that are specifically initialized in the program.\\
      For example:
      #+begin_src c
        int maxcount=99;
      #+end_src
    - Uninitilized data segment, often called the “bss” segment, \\
      named after an ancient assembler operator that stood for “block started by symbol.”
      #+begin_src c
        long sum[1024];
      #+end_src
    - Stack, where automatic variables are stored, \\
      along with information that is saved each time a function is called.
    - Heap, where dynamic memory allocation usually takes place.
      #+begin_src c
        malloc();
      #+end_src
      [[file:Chapter07/Figure7.6.png][Figure 7.6 Typical memory arrangement]]

*** DONE 7.7 Shared Libraries
    without shared libraries
    #+begin_src bash
      gcc -static hello.c
      size a.out
      text     data     bss     dec     hex	filename
      723103     7284    6392  736779   b3e0b	a.out
    #+end_src
    use shared libraries, the text and data size are greatly decreased
    #+begin_src bash
      gcc hello.c
      size a.out
      text     data     bss     dec     hex	filename
      1173      552       8    1733     6c5	a.out
    #+end_src
*** DONE 7.8 Memory Allocation
    =man 3 malloc=
    1. ~malloc~, allocates specified number of bytes of memory without initialized
    2. ~calloc~, allocates specified number of bytes of memroy with initializing to 0
    3. ~realloc~, increase or decrease the size of previous allocated area, the increased area was not initialized


    #+begin_src c
      #include <stdlib.h>
      void *malloc(size_t size);
      void *calloc(size_t nobj, size_t size);
      void *realloc(void *ptr, size_t newsize);

      void free(void*ptr);
    #+end_src


    - Alternative Memory Allocators
      - ~jemalloc~ \\
        designed to scale well when used with multithreaded applications running on multiprocessor systems.
      - ~TCMalloc~ \\
        for high performance, scalability, and memory efficiency.
      - ~alloca~ Function \\
        alloc memmory from stack, instaead of heap, so we don't have to free the space;
*** DONE 7.9 Environment Variable
    =man 3 getenv=
    #+begin_src c
      #include <stdlib.h>
      char *getenv(const char *name);
      int putenv(char *str);
      int setenv(const char *name, const char *value, int rewrite);
      int unsetenv(const char *name);
    #+end_src

    *malloc*

*** DONE 7.10 ~setjmp~ and ~longjmp~ Functions
    - *useful for dealing errors and interrupts*

    - Example \\
      #+caption: Figure 7.9 Typical program skeleton for command-processing
      #+include: "Chapter07/cmd_add.c" src c \\


    =man 3 setjmp=
    - Example \\
      #+caption: Figure 7.13 Effect of longjmp on various type of variables
      #+include: "Chapter07/testjmp.c" src c
    - *Automatic, Register and Volatile Variables* \\
      Most implementations do not try to roll back these automatic variables and register variables, but the standards say only that their values are indeterminate


    *Potential Problem with Automatic Variables*
    #+caption: Figure 7.14 Incorrect usage of an automatic variable
    #+include: "Chapter07/incorrect_usage.c" src c
    #+begin_quote
    The problem is that when open_data returns, the space it used on the stack will be used by the stack frame for the next function that is called. But the standard I/O library will still be using that portion of memory for its stream buffer. Chaos is sure to result. To correct this problem, the array databuf needs to be allocated from global memory, either statically (static or extern) or dynamically (one of the alloc functions)
    #+end_quote
*** DONE ~getrlimit~ and ~setrlimit~ Functions
    =man 3 getrlimit=
    - Example \\
      #+caption: Figure 7.16 print the current resource limits
      #+include: "Chapter07/rlimit.c" src c
*** DONE Summary
    *Exercises*
    1. the length of "hello, world"
    2. =man 3 exit=
    3. Nope
    4. *for NULL usage*
    5. =typedef void Exitfunc(void);= \\
       =int atexit(Exitfunc *func);=
    6. Yep, not sure
    7. the heap and stack aren't allocated before applying
    8. a.out include symbol info
    9. standard I/O library was copied
    10. Nope. num in heap
** DONE Chapter 8. Process Control [18/18]
   CLOSED: [2019-11-08 Fri 00:38]
*** DONE 8.1 Introduction
*** DONE 8.2 Process Identifiers
    Process ID 0 is usually the scheduler process and is often know as /swapper/.
    Process ID 1 is usually the *init* process.
    responsible for bring up a UNIX system after the kernel has been bootstrapped
    Process ID 2 is pagedaemon.
    responsible for supporting paging of virtual memory system.

    =man 2 getpid=
    #+begin_src c
      #include <unistd.h> pid_t getpid(void);
      // Returns: process ID of calling process

      pid_t getppid(void);
      // Returns: parent process ID of calling process

      uid_t getuid(void);
      // Returns: real user ID of calling process

      uid_t geteuid(void);
      // Returns: effective user ID of calling process

      gid_t getgid(void);
      // Returns: real group ID of calling process

      gid_t getegid(void);
      // Returns: effective group ID of calling process
    #+end_src

    #+begin_quote
    Note that none of these functions has an error return.
    #+end_quote
*** DONE 8.3 ~fork~ Function

    =man 3 fork=
    #+BEGIN_SRC c
      pid_t fork(void);
      // Returns: 0 in child, process ID of child in parent, −1 on error
    #+END_SRC


    #+BEGIN_QUOTE
    called once but return twice.

    return value in child is 0, whereas the return value in the parent is the process ID of the new child

    the child gets a copy of the parent’s data space, heap, and stack, parents and child do not share memmory
    #+END_QUOTE

    - Example \\
      #+caption: Figure 8.1 Example of fork function
      #+include: "Chapter08/fork.c" src c \\
    *changes to variables in a child process do not affect the value of the variables in the parent process.*
    - File Sharing
      handling the descriptors after a fork.
      1. The parent waits for the child to complete.
      2. Both the parent and the child go their own ways. after fork, close needless descriptors(*socket*)


    - inherits:
      - Real user ID, real group ID, effective user ID, and effective group ID
      - Supplementary group IDs
      - Process group ID
      - Session ID
      - Controlling terminal
      - The set-user-ID and set-group-ID ﬂags
      - Current working directory
      - Root directory
      - File mode creation mask
      - Signal mask and dispositions
      - The close-on-exec ﬂag for any open file descriptors
      - Environment
      - Attached shared memory segments
      - Memory mappings
      - Resource limits

    - differences
      - return value
      - process id
      - parent id
      - child's tms_utime, tms_stime, tms_cutime, tms_cstime set to 0
      - parent's file locks are not inherited
      - pending alarms are cleared for the child
      - pending signals set is set to empty for child

    - There are two uses for fork:
      #+begin_quote
      1. When a process wants to duplicate itself so that the parent and the child can each execute different sections of code at the same time.
      2. When a process wants to execute a different program.
      #+end_quote
*** DONE 8.4 ~vfork~ Function
    #+begin_quote
    just like fork, without copying the address space of the parent into the child, as the child won’t reference that address space

    the child runs in the address space of the parent until it calls either exec or exit.

    *vfork guarantees that the child runs first, until the child calls exec or exit.*
    #+end_quote
    - Example \\
      #+caption: Figure 8.3 Example of vfork function
      #+include: "Chapter08/vfork.c" src c
*** DONE 8.5 ~exit~ Function
    #+begin_quote
    As we described in Section 7.3, a process can terminate normally in five ways:
    1.  Executing a return from the main function.
    2.  Calling the exit function.
    3.  Calling the _exit or _Exit function. *terminate without running exit handlers or signal handlers.*
    4.  Executing a return from the start routine of the last thread in the process.
    5.  Calling the pthread_exit function from the last thread in the process.
    #+end_quote

    #+begin_quote
    The three forms of abnormal termination are as follows:
    1.  Calling abort. generates *SIGABRT* signal
    2.  When the process receives certain signals.
    3.  The last thread responds to a cancellation request.
    #+end_quote

    #+begin_quote
    - In UNIX System terminology, a process that has terminated, but whose parent has not yet waited for it, is called a zombie.

    - The ps(1) command prints the state of a zombie process as Z.
    #+end_quote
*** DONE 8.6 ~wait~ and ~waitpid~ Functions
    #+begin_quote
    we need to be aware that a process that calls wait or waitpid can
    - Block, if all of its children are still running
    - Return immediately with the termination status of a child, if a child has terminated and is waiting for its termination for its termination status to be fetched
    - Return immediately with an error, if it doesn't have any child processes
    #+end_quote


    =man 2 wait=
    #+begin_src c
      #include <sys/wait.h>
      pid_t wait(int *statloc);
      pid_t waitpid(pid_t pid, int *statloc, int options);

      Both return: process ID if OK, 0(see later), or -1 on error
    #+end_src

    - Example \\
      #+caption: Figure 8.5 Print a description of the exit status
      #+include: "Chapter08/exit_status.c" src c \\
      #+caption: Figure 8.6 Demonstrate various exit status
      #+include: "Chapter08/exit.c" src c

    #+begin_quote
    The waitpid function provides three features that aren’t provided by the wait function.
    1.  The waitpid function lets us wait for one particular process, whereas the wait function returns the status of any terminated child.
    2.  The waitpid function provides a nonblocking version of wait.
    3.  The waitpid function provides support for job control with the WUNTRACED and WCONTINUED options.
    #+end_quote

    - Example \\
      #+caption: Figure 8.8 Avoid zombie processes by calling fork twice
      #+include: "Chapter08/waitpid.c" src c
*** DONE 8.7 ~waitid~ Function
    =man 2 waitid=
    #+begin_src c
      #include <sys/wait.h> int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
      // Returns: 0 if OK, −1 on error
    #+end_src
    (OS X can't get the info, but the function is valid)
*** DONE 8.8 ~wait3~ and ~wait4~ Functions
    =man 2 wait3=
*** DONE 8.9 Race Conditions
    *Avoid race by signal*
    - Example \\
      #+caption: Figure 8.12 Program with a race condition
      #+include: "Chapter08/race.c" src c \\
      #+caption: Figure 8.13 Modification of Figure 8.12 to avoid race condition
      #+include: "Chapter08/avoid_race.c" src c
*** DONE 8.10 ~exec~ Functions
    =man 3 exec=
    #+begin_src c
      #include <unistd.h>
      int execl(const char *pathname, const char *arg0, ... /* (char *)0 */ );
      int execv(const char *pathname, char *const argv[]);
      int execle(const char *pathname, const char *arg0, ...
                 /* (char *)0, char *const envp[] */ );
      int execve(const char *pathname, char *const argv[], char *const envp[]);
      int execlp(const char *filename, const char *arg0, ... /* (char *)0 */ );
      int execvp(const char *filename, char *const argv[]);
      int fexecve(int fd, char *const argv[], char *const envp[]);
    #+end_src
    Returns: All seven return: −1 on error, no return on success


    #+begin_quote
    The first difference in these functions is that the first four take a pathname argument, the next two take a filename argument, and the last one takes a file descriptor argument. When a filename argument is specified,
    - If filename contains a slash, it is taken as a pathname.
    - Otherwise, the executable file is searched for in the directories specified by the *PATH* environment variable.
    #+end_quote


    ~execlp~ and ~execvp~ assume *link* as a *shell script*, and try to invoke ~/bin/sh~ with *filename*


    #+begin_quote
    The letter *p* means that the function takes a filename argument and uses the PATH environment variable to find the executable file
    The letter *l* means that the function takes a list of arguments and is mutually exclusive
    The letter *v*, means that it takes an argv[] vector.
    Finally, the letter *e* means that the function takes an envp[] array instead of using the current environment.
    #+end_quote


    #+CAPTION: Figure 8.14 Differences among the seven exec functions
    [[file:Chapter08/Figure8.14.png]]

    #+CAPTION: Figure 8.15 Relationship of the seven exec functions
    [[file:Chapter08/Figure8.15.png]]


    - Example \\
      #+caption: Figure 8.16 Example of exec functions
      #+include: "Chapter08/exec.c" src c \\
      #+caption: Figure 8.17 Echo all command-line arguments and all environment strings
      #+include: "Chapter08/echo_env.c" src c
*** DONE 8.11 Changing User IDs and Group IDs
    =man 2 setuid=
    #+begin_quote
    1. If the process has superuser privileges, the setuid function sets the real user ID, effective user ID, and saved set-user-ID to uid.

    2. If the process does not have superuser privileges, but uid equals either the real user ID or the saved set-user-ID, setuid sets only the effective user ID to uid. The real user ID and the saved set-user-ID are not changed.

    3. If neither of these two conditions is true, errno is set to EPERM and −1 is returned.
    #+end_quote
    #+caption: Figure 8.18 Ways to change the three user IDs
    file:Chapter08/Figure8.18.png
    =man 2 setreuid=
    =man 2 setregid=
*** DONE 8.12 Interpreter Files
    - Example \\
      #+caption: Figure 8.20 A program that execs an interpreter file
      #+include: "Chapter08/exec_intr.c" src c \\
      #+caption: Figure 8.21 An awk program as an interpreter file
      #+include: "Chapter08/awkexample" src c
*** DONE 8.13 ~system~ Function
    #+begin_src c
      #include <stdlib.h>
      int system(const char *cmdstring);
    #+end_src
    *if /cmdstring/ is a ~NULL~, ~system~ returns nonzero only if a command processor is available.
    #+begin_quote
    1. If either the fork fails or waitpid returns an error other than EINTR, system returns −1 with errno set to indicate the error.

    2. If the exec fails, implying that the shell can’t be executed, the return value is as if the shell had executed exit(127).

    3. Otherwise, all three functions—fork, exec, and waitpid—succeed, and the return value from system is the termination status of the shell, in the format specified for waitpid.
    #+end_quote
    - Example \\
      #+caption: Figure 8.22 The system function, without signal handling
      #+include: "Chapter08/fig8.22.c" src c
      #+caption: Figure 8.23 Calling the system function
      #+include: "Chapter08/fig8.22.c" src c

    #+begin_quote
    The advantage in using system, instead of using fork and exec directly, is that system does all the required error handling and (in our next version of this function in Section 10.18) all the required signal handling.
    #+end_quote



    *Set-User-ID Programs*
    #+caption: Figure 8.24 Execute the command-line argument using system
    #+include: "Chapter08/systest.c" src c

    #+caption: Figure 8.25 Print real and effective user IDs
    #+include; "Chapter08/pruids.c" src c
*** DONE 8.14 Process Accounting
    - Example \\
      #+caption: Figure 8.28 Program to generate accounting data
      #+include: "Chapter08/acct_data.c" src c \\
      #+caption: Figure 8.29 Print select fields from system's accounting file
      #+include: "Chapter08/print_sel_acct.c" src c
*** DONE 8.15 User Identification
    =man 2 getlogin=
    #+caption: getlogin
    #+include: "Chapter08/getlogin.c" src c
*** DONE 8.16 Process Scheduling
    Lower nice values have higher scheduling priority.

    =man 3 nice=
    =man 3 getpriority=
    - Example \\
      #+caption: Figure 8.30 Evaluate the effect of changing the nice value
      #+include: "Chapter08/fig8.30.c" src c
*** DONE 8.17 Process Times
    #+begin_src c
      #include <sys/times.h>
      clock_t times(struct tms *buf);

      // Returns: elapsed wall clock time in clock ticks if OK, -1 on error
    #+end_src
    #+caption: Figure 8.31 Time and execute all command-line arguments
    #+include: "Chapter08/pr_times.c" src c
*** DONE 8.18 Summary
    functions to master: ~fork~, ~exec~ family, ~_exit~, ~wait~ and ~waitpid~.

    ~fork~ function gave us an opportunity to look at race conditions.

    - Exercises
      -
        #+caption: 8.1
        #+include: "Chapter08/ex8.1.c" src c
      -
        #+caption: 8.2
        #+include: "Chapter08/ex8.2.c" src c
      -
        #+caption: 8.3
        #+include: "Chapter08/ex8.1.c" src c
      - 8.4
    In Figure 8.13, we have the parent write its output first. When the parent is done, the child writes its output, but we let the parent terminate. Whether the parent terminates or whether the child finishes its output first depends on the kernel’s scheduling of the two processes (another race condition). When the parent terminates, the shell starts up the next program, and this next program can interfere with the output from the previous child.
    We can prevent this from happening by not letting the parent terminate until the child has also finished its output. Replace the code following the fork with the following:
    #+begin_src c
       else if (pid ~~ 0) {
         WAIT_PARENT(); /* parent goes first */
         charatatime("output from child\n");
         TELL_PARENT(getppid()); /* tell parent we’re done */
       } else {
         charatatime("output from parent\n");
         TELL_CHILD(pid);
         /* tell child we’re done */
         WAIT_CHILD(); /* wait for child to finish */
       }
    #+end_src
    We won’t see this happen if we let the child go first, since the shell doesn’t start the next program until the parent terminates.
    - 8.5 The same value
    -
      #+caption: 8.6
      #+include: "Chapter08/ex8.6.c" src c
** TODO Chapter 9. Process Relationships [2/12]
*** DONE 9.1 Introduction
*** DONE 9.2 Terminal Logins
    CLOSED: [2019-11-08 Fri 09:48]
    - BSD Terminal Logins
      #+caption: Figure 9.1 Processes invoked by init to allow terminal logins
      [[file:Chapter09/fig9.1.png][file:Chapter09/fig9.1.png]]
      #+begin_quote
      a real user ID of 0 and an effective user ID of 0
      #+end_quote

      =login= program similar to
      #+begin_src c
        execle("/bin/login", "login", "-p", username, (char *)0, envp);
      #+end_src

*** TODO 9.3 Network Logins
*** TODO 9.4 Process Groups
    #+begin_src c
      getpgid(0) ~~ getpgrp();
    #+end_src
*** TODO 9.5 Sessions
*** TODO 9.6 Controlling Terminal
*** TODO 9.7 ~tcgetpgrp~, ~tcsetpgrp~, and ~tcgetsid~ Functions
*** TODO 9.8 Job Control
    Requirements:
    1. A shell that supports job control
    2. The terminal driver in the kernel must support job control
    3. The kernel must support certain job-control signals


    #+begin_src sh
      cat > temp.foo & # & let start in background
      fg % 1 # % bring job number into the foreground
    #+end_src
    #+begin_src sh
      stty tostop # disable ability of background to output to controlling terminal
    #+end_src
*** TODO 9.9 Shell Execution Programs
*** TODO 9.10 Orphaned Process Groups
*** TODO 9.11 FreeBSD Implementation
*** TODO 9.12 Summary
** DONE Chapter 10. Signals [23/23]
   CLOSED: [2019-11-08 Fri 00:38]
*** DONE 10.1 Introduction
    #+begin_quote
    Signals provide a way of handling asynchronous events
    #+end_quote
*** DONE 10.2 Signal Concepts
    ~<signal.h>~
    conditions can generate a signal
    * terminal generated when users press certain terminal keys.
    * hardware exceptions
    * function ~kill~ (man 2 kill)
    * command ~kill~ (man 1 kill)
    * software conditions : ~SIGURG~ ~SIGPIPE~ ~SIGALARM~


    deal with signals via one of things below:
    * ignore
    * catch
    * use defaut action apply


    #+caption: Figure 10.1 UNIX System signals
    | Name       | Description                                          | Default Action              |
    |------------+------------------------------------------------------+-----------------------------|
    | SIGABRT    | abnormal termination(abort)                          | terminate+core              |
    | SIGALARM   | timer expired(alarm)                                 | terminate                   |
    | SIGBUS     | hardware fault                                       | terminate+core              |
    | SIGCHLD    | change in the status of child                        | ignore                      |
    | SIGCONT    | continue stopped process                             | continue/ignore             |
    | SIGEMT     | hardware fault                                       | terminate+core              |
    | SIGFPE     | arithmetic exception                                 | terminate+core              |
    | SIGFREEZE  | checkpoint freeze                                    | ignore                      |
    | SIGHUP     | hangup                                               | terminate                   |
    | SIGILL     | illegal instruction                                  | terminate+core              |
    | SIGINFO    | status request from keyboard                         | ignore                      |
    | SIGINT     | terminal interrupt character                         | terminate                   |
    | SIGIO      | asynchronous I/O                                     | terminate/ignore            |
    | SIGIOT     | hardware fault                                       | terminate+core              |
    | SIGKILL    | termination : *can't be caught or ignored*           | terminate                   |
    | SIGPIPE    | write to pipe with no readers                        | terminate                   |
    | SIGPOLL    | pollable event(poll): *might be removed*             | terminate                   |
    | SIGPROF    | profiling time alarm(setitimer):  *might be removed* | terminate                   |
    | SIGPWR     | power fail/restart                                   | terminate/ignore            |
    | SIGQUIT    | terminal quit character                              | terminate+core              |
    | SIGSEGV    | invalid memory reference                             | terminate+core              |
    | SIGSTKFLT  | coprocessor stack fault                              | terminate                   |
    | SIGSTOP    | stop: *can't be caught or ignored*                   | stop process                |
    | SIGSYS     | invalid system call                                  | terminate+core              |
    | SIGTERM    | termination                                          | terminate                   |
    | SIGTHAW    | checkpoint thaw                                      | ignore                      |
    | SIGTHR     | threads library internal use                         | terminate                   |
    | SIGTRAP    | hardware fault                                       | terminate+core              |
    | SIGTSTP    | terminal stop character                              | stop process                |
    | SIGTTIN    | background read from control tty                     | stop process                |
    | SIGTTOU    | background write to control tty                      | stop process                |
    | SIGURG     | urgent condition(sockets)                            | ignore                      |
    | SIGUSR1    | user-defined signal                                  | terminate                   |
    | SIGUSR2    | user-defined signal                                  | terminate                   |
    | SIGVTALRM  | virtual time alarm(setitimer)                        | terminate                   |
    | SIGWAITING | threads library internal use                         | ignore                      |
    | SIGWINCH   | terminal window size change                          | ignore                      |
    | SIGXCPU    | CPU limit exceeded (setrlimit)                       | terminate or terminate+core |
    | SIGXFSZ    | file size limit exceeded(setrlimit0)                 | terminate or terminate+core |
    | SIGXRES    | resource control exceeded                            | ignore                      |

    #+begin_quote
    The core file will not be generated if
    1. the process was set-user-ID and the current user is not the owner of the program file
    2. the process was set-group-ID and the current user is not the group owner of the file
    3. the user does not have permission to write in the current working directory
    4. the file already exists and the user does not have permission to write it
    5. the file is too big (recall the RLIMIT_CORE)

    The permission of the core file are usually ~rw~, although Mac OSX sets only ~r~
    #+end_quote

*** DONE 10.3 ~signal~ Function
    #+begin_src sh
      man signal
    #+end_src

    - Example: \\
    #+caption: Figure 10.2 Simple program to catch SIGUSR1 and SIGUSR2
    #+include: "Chapter10/fig10.2.c" src c
    #+begin_quote
    FreeBSD 8.0 and Mac OS X 10.6.8 don’t exhibit this problem, because BSD - based systems generally don’t support historical System V semantics for SIGCLD. Linux 3.2.0 also doesn’t exhibit this problem, because it doesn’t call the SIGCHLD signal handler when a process arranges to catch SIGCHLD and child processes are ready to be waited for, even though SIGCLD and SIGCHLD are defined to be the same value.
    #+end_quote

    - Program Start-Up
      we are not able to determine the current disposition of a signal without changing the disposition
*** DONE 10.4 Unreliable Signals
    In ealier versions of the UNIX system :
    - signals could get lost
    - the process was unable to turn a signal off when it didn’t want the signal to occur
*** DONE 10.5 Interrupted System Calls
    - automatically restarted functions: ~ioctl~, ~read~, ~readv~, ~write~, ~writev~, ~wait~, ~waitpid~ \\
      POSIX.1 requires an implementation to restart system calls only when the SA_RESTART ﬂag is in effect for the interrupting signal.
*** DONE 10.6 Reentrant Functions
    #+caption: Figure 10.5 Call a nonreentrant function from a signal handler
    #+include: "Chapter10/fig10.5.c" src c

*** DONE 10.7 ~SIGCLD~ Semantics
    #+caption: Figure 10.6 System V SIGCLD handler that doesn't work
    #+include: "Chapter10/fig10.6.c" src c
*** DONE 10.8 Reliable-Signal Terminology and Semantics
    #+begin_quote
    If the system delivers the signal more than once, we say that the signals are queued. \\
    *Most UNIX systems do /not/ queue signals unless they support the real-time extensions to POSIX.1.* \\
    POSIX.1 *does not specify the order* in which the signals are delivered to the process more than once.
    #+end_quote

    * /signal mask/: a set of signals currently blocked from delivery to the process (*on* is blocked)
    * /~sigprocmask~/: examine and change its current signal mask
*** DONE 10.9 ~kill~ and ~raise~ Functions
    #+begin_src c
      #include <signal.h>
      int kill(pid_t pid, int signo);
      int raise(int signo);

      // Both return: 0 if OK, -1 on error
    #+end_src

    ~raise(signo);~ is equivalent to ~kill(getpid(), signo);~

*** DONE 10.10 ~alarm~ and ~pause~ Functions
    #+begin_src c
      #include <unistd.h>
      unsigned int alarm(unsigned int seconds);
      // Returns: 0 or number of seconds until previously set alarm
    #+end_src

    #+begin_quote

There is only one of these alarm clocks per process. If, when we call alarm, a previously registered alarm clock for the process has not yet expired, the number of seconds left for that alarm clock is returned as the value of this function.

If a previously registered alarm clock for the process has not yet expired and if the seconds value is 0, the previous alarm clock is canceled.

If we call alarm first and are sent SIGALRM before we can install the signal handler, our process will terminate
    #+end_quote


    suspends the calling process until a signal is caught
    #+begin_src c
      #include <unistd.h>
      int pause(void);
      // Returns: -1 with errno set to EINTR
    #+end_src


    - Example:
      #+caption: Figure 10.7 Simple, incomplete implementation of sleep
      #+include: "Chapter10/fig10.7.c" src c
      #+caption: Figure 10.8 Another (imperfect) implementation of sleep
      #+include: "Chapter10/fig10.8.c" src c
      #+caption: Figure 10.9 Calling sleep2 from a program that catches other signals
      #+include: "Chapter10/fig10.9.c" src c
      #+caption: Figure 10.10 Calling ~read~ with a timeout
      #+include: "Chapter10/fig10.10.c" src c
      #+caption: Figure 10.11 Calling ~read~ with a timeout, using longjmp
      #+include: "Chapter10/fig10.11.c" src c

*** DONE 10.11 Signal Sets
    #+begin_src c
      #include <signal.h>
      int sigemptyset(sigset_t *set);
      int sigfillset(sigset_t *set);
      int sigaddset(sigset *set, int signo);
      int sigdelset(sigset *set, int signo);
      // All four returns: 0 if OK, -1 on error

      int sigismember(const sigset *set, int signo);
      // Returns: 1 if true, 0 if false, -1 on error
    #+end_src

    Implementation:
    #+begin_src c
      #define sigemptyset(ptr)  (*(ptr) = 0)
      #define sigfillset(ptr)   (*(ptr) = ~(sigset_t)0, 0)
    #+end_src
    ~sigfillset~ returns value after the comma (value: 0)

    #+caption: Figure 10.12 An implementation of ~sigaddset~, ~sigdelset~, and ~sigismember~

    #+include: "Chapter10/fig10.12.c" src c

*** DONE 10.12 ~sigprocmask~ Function
    #+begin_src c
      #include <signal.h>

      int sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict oset);

      // Returns: 0 if OK, -1 on error
    #+end_src

    #+caption: Figure 10.13 Ways to change the current signal mask using sigprocmask
    | how           | Description                                                    |
    |---------------+----------------------------------------------------------------|
    | ~SIG_BLOCK~   | /set/ contains the additional signals that we want to block.   |
    | ~SIG_UNBLOCK~ | /set/ contains the signals that we want to unblock             |
    | ~SIG_SETMASK~ | new signal mask replaced by the signal set pointed to by /set/ |

    - Example:
      #+caption: Figure 10.14 Print the signal mask for the process
      #+include: "Chapter10/fig10.14.c" src c

*** DONE 10.13 ~sigpending~ Function
    #+begin_src c
      #include <signal.h>
      int sigpending(sigset_t *set);
      // Returns: 0 if OK, -1 on error
    #+end_src

    - Example:
      #+caption: Example of signal sets and sigprocmask
      #+include: "Chapter10/fig10.5.c" src c
*** DONE 10.14 ~sigaction~ Function
    #+begin_src c
      #include <signal.h>
      int sigaction (int signo, const struct sigaction* restrict act, struct sigaction* restrict oact);
      // Returns: 0 if OK, -1 on error
    #+end_src

    #+begin_src c
      struct sigaction {
        void (*sa_handler) (int);       // addr of signal handler or SIG_IGN or SIG_DFL

        sigset_t sa_mask;               // addtional signals to block
        int sa_flags;                   // signal options, Figure 10.16

        // alternate handler
        void (*sa_action)(int, siginfo_t *, void*);
      };
    #+end_src

    #+caption: Figure 10.16 Option ﬂags (sa_flags) for the handling of each signal
    | Option       | SUS | FreeBSD | Linux | Mac OSX | Solaris | Description                                                                                   |
    |--------------+-----+---------+-------+---------+---------+-----------------------------------------------------------------------------------------------|
    | SA_INTERRUPT | *   |         | *     |         |         | system call interrupted by this signal are not automatically restarted                        |
    | SA_NOCLDSTOP | *   | *       | *     | *       | *       | SIGCHLD do not generate signal when a child process stops(job control).                       |
    | SA_NOCLDWAIT | *   | *       | *     | *       | *       | SIGCHLD prevents the system call from creating process zombie processes                       |
    |              |     |         |       |         |         | when children of the calling process terminate.                                               |
    |              |     |         |       |         |         | if the subsequently calls wait, the calling process blocks until all                          |
    |              |     |         |       |         |         | its child processes have terminated and then returns -1 when errno set to ECHILD              |
    | SA_NODEFER   | *   | *       | *     | *       | *       | signal is not automatically blocked by the system while the signao-catching function executes |
    | SA_ONSTACK   | XSI | *       | *     | *       | *       | if an alternative stack has been declared with ~signalstack~[fn:1]                            |
    | SA_RESETHAND | *   | *       | *     | *       | *       | the disposition for this signal is reset to SIG_DFL, and the SA_SIGINFO flag is cleared       |
    | SA_RESTART   | *   | *       | *     | *       | *       | system calls interrupted by this signal are automatically restarted                           |
    | SA_SIGINFO   | *   | *       | *     | *       | *       | provides additional information to a signal hander                                           |


    #+begin_src c
      // normal signal handler
      void handler(int signo);

      // if SA_SIGINFO flag is set
      void handler(int signo, siginfo_t *info, void *context);

      struct siginfo {
        int si_signo;          // signal number
        int si_errno;          // if nonzero, errno value from errno.h
        int si_code;           // additional info (depends on signal)
        pid_t si_pid;          // sending process ID
        uid_t si_uid;          // sending process real user ID
        void *si_addr;         // address that caused the fault
        int si_status;         // exit value or signal number
        union sigval si_value; // application-specific value
        // possibly other fields also
      };
      union sigval {int sival_int; void* sival_ptr; };

    #+end_src


    ~man sigaction~ (linux)for details

    - Example - ~signal~ function
      #+caption: Figure 10.18 An implementation of signal using sigaction
      #+include: "Chapter10/fig10.18.c" src c

    - Example - ~signal_intr~ function
      #+caption: Figure 10.19 The signal_intr function
      #+include: "Chapter10/fig10.19.c" src c

*** DONE 10.15 ~sigsetjmp~ and ~siglongjmp~ Functions
    These two functions should always be used when branching from a signal handler.
    #+begin_src c
      #include <setjmp.h>
      int sigsetjmp(sigjmp_buf env, int savemask);
      // Returns: 0 if called directly, nonzero if returning from a call to siglongjmp
      void siglongjmp(sigjmp_buf env, int val);
    #+end_src


    - Example
      #+caption: Figure 10.20 Example of signal masks, sigsetjmp, and siglongjmp
      #+include: "Chapter10/fig10.20.c" src c

      #+begin_quote
      If we change the program in Figure 10.20 so that the calls to sigsetjmp and siglongjmp are replaced with calls to setjmp and longjmp on Linux (or _setjmp and _longjmp on FreeBSD), the final line of output becomes

      ending main: SIGUSR1

      This means that the main function is executing with the SIGUSR1 signal blocked, after the call to setjmp.
      #+end_quote

*** DONE 10.16 ~sigsuspend~ Function
    #+begin_src c
      #include <signal.h>
      int sigsuspend(const sigset_t *sigmask);
      // Returns: −1 with errno set to EINTR
    #+end_src

    - Example
      #+caption: Figure 10.22 Protecting a critical region from a signal
      #+include: "Chapter10/fig10.22.c" src c
    - Example
      #+caption: Figure 10.23 Using sigsuspend to wait for a global variable to be set
      #+include: "Chapter10/fig10.23.c" src c
    - Example
      #+caption: Figure 10.24 Routines to allow a parent and child to synchronize
      #+include: "Chapter10/fig10.24.c" src c

    #+begin_quote
    1. Block SIGINT and SIGALRM.

    2. Test the two global variables to see whether either signal has occurred and, if so, handle the condition.

    3. Call read (or any other system function) and unblock the two signals, as an atomic operation.

    The sigsuspend function helps us only if step 3 is a pause operation.
    #+end_quote

*** DONE 10.17 ~abort~ Function
    #+begin_src c
      #include <stdlib.h>
      void abort(void);
    #+end_src

    #+caption: Figure 10.25 Implementation of POSIX.1 ~abort~
    #+include: "Chapter10/fig10.25.c" src c
*** DONE 10.18 ~system~ Function

    #+caption: Figure 10.26 Using ~system~ to invoke the =ed= editor
    #+include: "Chapter10/fig10.26.c" src c

    #+caption: Figure 10.27 Foreground and background process groups for Figure 10.26
    [[file:Chapter10/fig10.27.png]]

    #+caption: Figure 10.28 Correct POSIX.1 implementation of ~system~ function
    #+include: "Chapter10/fig10.28.c" src c

*** DONE 10.19 ~sleep~, ~nanaosleep~, and ~clock_nanosleep~ Functions
    #+begin_src c
      #include <unistd.h>
      unsigned int sleep(unsigned int seconds);
      // Returns: 0 or number of unslept seconds
    #+end_src

    #+caption: Figure 10.29 Reliable implementation of ~sleep~
    #+include: "Chapter10/fig10.29.c" src c

    #+begin_src c
      #include <time.h>
      int clock_nanosleep(clockid_t clock_id, int flags,
                          const struct timespec* reqtp, struct timespec* remtp);
      // Returns: 0 if slept for requested time or error number on failue
    #+end_src

*** DONE 10.20 ~sigqueue~ Function
    - Specify the SA_SIGINFO ﬂag when we install a signal handler using the sigaction function
    - Provide a signal handler in the sa_sigaction member of the sigaction structure instead of using the usual sa_handler field.
    - Use the sigqueue function to send signals.
      #+begin_src c
        #include <signal.h>

        int sigqueue(pid_t pid, int signo, const union sigval value);
        // Returns: 0 if OK, -1 on error
      #+end_src
      #+caption: Figure 10.30 Behavior of queued signals on various platforms
      | Behavior                                                         | SUS      | FreeBSD8.0 | Linux3.2.0 | Mac OSX | Solaris |
      |------------------------------------------------------------------+----------+------------+------------+---------+---------|
      | supports sigqueue                                                | *        | *          | *          |         | *       |
      | queues other signals besides SIGRTMIN to SIGRTMAX                | optional | *          |            |         | *       |
      | queues signals even if the caller don't use the SA_SIGINFO flags | optional | *          | *          |         |         |

*** DONE 10.21 Job-Control Signals
    job-control signals:
    SIGCHLD   Child process has stopped or terminated
    SIGCONT   Continue process, if stopped.
    SIGSTOP   Stop signal(can't caught or ignored)
    SIGTSTP   Interactive stop signal.
    SIGTTIN   Read from controlling terminately by background process group number
    SIGTTOU   Write to controlling terminal by a background process group member

    #+caption: Figure 10.31 How to handle SIGTSTP
    #+include: "Chapter10/fig10.31.c" src c
*** DONE 10.22 Signal Names and Numbers
    map between signal numbers and names.
    #+begin_src  c
      extern char *sys_siglist[];
    #+end_src

    in a portable manner
    #+begin_src c
      #include <signal.h>
      void psignal(int signo, const char *msg);
    #+end_src

    print signal information
    #+begin_src c
      #include <signal.h>
      void psiginfo(const siginfo_t* info, const char *msg);
    #+end_src

    string description of the signal and don't necessarily wnat to write it to standard error
    #+begin_src c
      #include <string.h>
      char *strsignal(int signo);
      // Returns: a pointer to a string describing the signal
    #+end_src

    *Solaris provides*
    #+begin_src c
      #include <signal.h>
      int sig2str(int signo, char *str);
      int str2sig(const char *str, int *signop);
      // Both return: 0 if OK, -1 on error
    #+end_src

*** DONE 10.23 Summary
    - Exercises
      - 10.1
        #+begin_quote
        terminates the first time
        ~pause~ until a signal is received from either the kill(2) function or an interval timer
        #+end_quote
      - 10.2
        #+include: "Chapter10/ex10.2.c" src c
      - 10.3
        [[file:Chapter10/ex10.3.png][file:~/Documents/Notes/books/system/APUE/Chapter10/ex10.3.png]]
      - 10.4
        race condition between first call ~alarm~ and ~setjmp~
      - 10.5
        [[http://www.kohala.com/start/libes.timers.txt][www.kohala.com/start/libes.timers.txt]]
      - 10.6
        #+include: "Chapter10/ex10.6.c" src c
      - 10.7
        #+begin_quote
        the termination status of the process would not show that it was terminated by the SIGABRT signal.
        #+end_quote
      - 10.8
        #+begin_quote
        If the signal was sent by a process owned by some other user, the process has to be set-user-ID to either root or to the owner of the receiving process, or the kill attempt won’t work. Therefore, the real user ID provides more information to the receiver of the signal.
        #+end_quote
      - 10.9
        #+include: "Chapter10/ex10.9.c" src c
      - 10.10
        #+include: "Chapter10/ex10.10.c" src c
      - 10.11
        #+include: "Chapter10/ex10.11.c" src c
        SIGXFSZ never caught
      - 10.12
        #+include: "Chapter10/ex10.2.c" src c
        finished, alarm appears until fwrite finshied, it seems the kernel is blocking SIGALRM
** DONE Chapter 11. Threads [7/7]
   CLOSED: [2019-11-14 Thu 22:35]
*** DONE 11.1 Introduction
    CLOSED: [2019-11-08 Fri 00:42]
*** DONE 11.2 Thread Concepts
    CLOSED: [2019-11-08 Fri 09:48]
    benefits
    - asynchronous
    - same memory address space and file descriptors
    - problem partition
    - seperate portions of the program
*** DONE 11.3 Thread Identification
    CLOSED: [2019-11-08 Fri 09:48]
    #+begin_src c
      #include <pthread.h>
      int pthread_equal(pthread_t tid1, pthread_t tid2);

      // Returns: nonzero if equal, 0 otherwise
    #+end_src

    obtain its own thread ID :
    #+begin_src c
      #include <pthread.h>
      pthread_t pthread_self(void);
      // Returns: the thread ID of the calling thread
    #+end_src
*** DONE 11.4 Thread Creation
    CLOSED: [2019-11-08 Fri 09:48]
    #+begin_src c
      #include <pthread.h>
      int pthread_create(pthread_t *restrict tidp,
                         const pthread_attr_t *restrict attr,
                         void *(*start_rtn)(void*),
                         void *restrict arg);
      // Returns: 0 if OK, error number on failure
    #+end_src

    - Example \\
      #+caption: Figure 11.2 Printing thread IDs
      #+include: "Chapter11/fig11.2.c" src c
*** DONE 11.5 Thread Termination
    CLOSED: [2019-11-08 Fri 09:49]
    1. thread return from start routine.
    2. can be canceled by another thread in the same process
    3. can call ~pthread_exit~
    #+begin_src c
      #include <pthread.h>
      void pthread_exit(void *rval_ptr);
    #+end_src

    #+begin_src c
      #include <pthread.h>
      int pthread_join(pthread_t thread, void **rval_ptr);
    #+end_src
    #+begin_quote
    The calling thread will block until the specified thread calls pthread_exit, returns from its start routine, or is canceled.
    #+end_quote

    #+begin_quote
    *The Linux Programming Language:*
    If the main thread calls pthread_exit() instead of calling exit() or performing a return, then the other threads continue to execute.
    #+end_quote
    - Example \\
      #+caption: Figure 11.3 Fetching the thread exit status
      #+include: "Chapter11/fig11.3.c" src c

    - Example \\
      #+caption: Figure 11.4 Incorrect use of ~pthread_exit~ argument
      #+include: "Chapter11/fig11.4.c" src c
      #+begin_quote
      the contents of the structure (allocated on the stack of thread tid1) have changed by the time the main thread can access the structure
      #+end_quote


    #+begin_src c
      #include <pthread.h>
      int pthread_cancel(pthread_t tid);
      // Returns: 0 if OK, error number on failure
    #+end_src
    in default circumstances, ~pthread_exit~ with *PTHREAD_CANCELD* \\
    doesn't wait for the thread to terminate; it merely makes the request. \\
    similar to ~atexit~ used by a process \\
    known as /thread cleanup handlers/

    #+begin_src c
      #include <pthread.h>
      void pthread_cleanup_push(void (*rtn)(void*), void *arg);
      void pthread_cleanup_pop(int execute);
    #+end_src
    #+begin_quote
    • Makes a call to pthread_exit

    • Responds to a cancellation request

    • Makes a call to pthread_cleanup_pop with a nonzero execute argument

    If the execute argument is set to zero, the cleanup function is not called
    #+end_quote


    - Example \\
      #+caption: Figure 11.5 Thread cleanup handler
      #+include: "Chapter11/fig11.5.c" src c
      #+begin_quote
      if the thread terminates by returning from its start routine, its cleanup handlers are not called, although this behavior varies among implementations
      #+end_quote


    #+caption: Figure 11.6 Comparison of process and thread primitives
    | Process primitives | Thread Primitive     | Description                                                 |
    |--------------------+----------------------+-------------------------------------------------------------|
    | fork               | pthread_create       | create a new flow of control                                |
    | exit               | pthread_exit         | exit from an existing flow of control                       |
    | waitpid            | pthread_join         | get exit status from flow of control                        |
    | atexit             | pthread_cleanup_push | register function to be called at exit from flow of control |
    | getpid             | pthread_self         | get ID for flow of control                                  |
    | abort              | pthread_cancel       | request abnormal termination of flow of control             |


    detach a thread by calling ~pthread_detach~
    #+begin_src c
      #include <pthread.h>
      int pthread_detach(pthread_t tid);
      // Returns: 0 if OK, error number on failure

    #+end_src
*** DONE 11.6 Thread Synchronization [8/8]
    CLOSED: [2019-11-14 Thu 20:58]
    Increment operation:
    #+begin_quote
    1. Read the memory location into a register.
    2. Increment the value in the register.
    3. Write the new value back to the memory location.


    *If our data always appears to be sequentially consistent, then we need no additional synchronization.*
    #+end_quote

    #+caption: Figure 11.9 Two unsynchronized threads incrementing the same variable
    [[file:Chapter11/fig11.9.png][file:Chapter11/fig11.9.png]]
**** DONE 11.6.1 Mutexes
     CLOSED: [2019-11-08 Fri 15:43]
     #+begin_src c
       #include <pthread.h>
       int pthread_mutex_init(pthread_mutex_t *restrict mutex,
                              const pthread_mutexattr_t *restrict attr);
       int pthread_mutex_destroy(pthread_mutex_t *mutex);
       // Both return: 0 if OK, error number on failure
     #+end_src

     #+begin_src c
       #include <pthread.h>
       int pthread_mutex_lock(pthread_mutex_t *mutex);
       int pthread_mutex_trylock(pthread_mutex_t *mutex);
       int pthread_mutex_unlock(pthread_mutex_t *mutex);
       // All return: 0 if OK, error number on failure
     #+end_src

     - Example \\
       #+caption: Figure 11.10 Using a mutex to protect a data structure
       #+include: "Chapter11/fig11.10.c" src c
**** DONE 11.6.2 Deadlock Avoidance
     CLOSED: [2019-11-08 Fri 15:43]
     lock the same mutex twice will cause deadlock

     Deadlocks can be avoided by carefully controlling the order in which mutexes are locked

     - Example
       #+caption: Figure 11.11 Using two mutexes
       #+include: "Chapter11/fig11.11.c" src c

     - Example
       #+caption: Figure 11.12 Simplified locking
       #+include: "Chapter11/fig11.12.c" src c
**** DONE 11.6.3 ~pthread_mutex_timedlock~ function
     CLOSED: [2019-11-08 Fri 15:53]
     *Mac OSX 10.15.1 doesn't support ~pthread_mutex_timedlock~ yet*

     ~pthread_mutex_timedlock~ is equivalent to ~pthread_mutex_lock~, but returns *ETIMEDOUT* without locking mutex after timeout

     #+begin_src c
       #include <pthread.h>
       #include <time.h>

       int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex,
                                   const struct timespec *restrict tsptr);

       // Returns: 0 if OK, error number on failure
     #+end_src

     - Example
       #+caption: Figure 11.13 Using ~pthread_mutex_timedlock~
       #+include: "Chapter11/fig11.13.c" src c
**** DONE 11.6.4 Reader-Writer Locks
     CLOSED: [2019-11-09 Sat 22:07]
     * mutex  : can only one thread lock it at a time, lock/unlock.
     * rw-lock: read lock, write lock, unlock.
     * rw-lock: only one thread can hold a rw-lock in write mode, but multiple threads can hold a rw-lock in read mode at the same time.
       * w-lock: all threads attempting to lock it block until it is unlocked (*exclusive mode*)
       * r-lock: all threads attempting to do r-lock are given access, but w-lock block (*shared mode*)


     #+begin_src c
       #include <pthread.h>
       int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,
                               const pthread_rwlockattr_t *restrict attr);
       int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
       // Both return: 0 if OK, error number on failure
     #+end_src
     The Single UNIX specification defines *PTHREAD_RWLOCK_INITIALIZE* constant in the XSI option to initialize a statically allocated rw lock.

     rw-lock control:
     #+begin_src c
       #include <pthread.h>
       int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
       int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
       int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
       // All return: 0 if OK, error number on failure
     #+end_src

     rw-lock try control:
     #+begin_src c
       #include <pthread.h>
       int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
       int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
       // Both return: 0 if OK, error number on failure
     #+end_src


     - Example
       #+caption: Figure 11.14 Using reader-writer locks
       #+include: "Chapter11/fig11.14.c" src c

**** DONE 11.6.5 Reader-Writer Locking with Timeouts
     CLOSED: [2019-11-09 Sat 22:25]
     rw-lock with timeout to avoid blocking indefinitely
     #+begin_src c
       #include <pthread.h>
       #include <time.h>

       int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rwlock,
                                      const struct timespec *restrict tsptr);
       int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict rwlock,
                                      const struct timespec *restrict tsptr);
       // Both return: 0 if OK, error number on failure
     #+end_src
     *the timeout specifies an absolute time, not a relative one.*
**** DONE 11.6.6 Condition Variables
     CLOSED: [2019-11-10 Sun 15:07]
     #+begin_quote
     The condition itself is protected by a mutex. A thread must first lock the mutex to change the condition state. Other threads will not notice the change until they acquire the mutex, because the mutex must be locked to be able to evaluate the condition.

     assign the constant PTHREAD_COND_INITIALIZER to a statically allocated condition variable
     #+end_quote

     ~pthread_cond_init/destroy~
     #+begin_src c
       #include <pthread.h>
       int pthread_cond_init(pthread_cond_t *restrict cond,
                             const pthread_condattr_t *restrict attr);
       int pthread_cond_destroy(pthread_cond_t *cond);
       // Both returns: 0 if OK, error number on failure
     #+end_src

     ~pthread_cond wait/timedwait~
     #+begin_src c
       #include <pthread.h>
       int pthread_cond_wait(pthread_cond_t *restrict cond,
                             pthread_mutex_t *restrict mutex);
       int pthread_cond_timedwait(pthread_cond_t *restrict cond,
                                  pthread_mutex_t *restrict mutex,
                                  const struct timespec *restrict tsptr);
       // Both return: 0 if OK, error number on failure
     #+end_src
     wait as an absolute time instead of a relative time.

     To obtain the absolute time for the timeout value,
     #+begin_src c
       #include <sys/time.h>
       #include <stdlib.h>

       void maketimeout(struct timespec *tsp, long minutes) {
         struct timeval now;

         // get the current time
         gettimeofday(&now, NULL);
         tsp->tv_sec = now.tv_sec;
         tsp->tv_nsec = now.tv_usec * 1000; // usec to nsec
         tsp->tv_sec += minutes * 60;
       }
     #+end_src


     notify threads that a condition has been satisfied.
     #+begin_src c
       #include <pthread.h>
       int pthread_cond_signal(pthread_cond_t *cond);
       int pthread_cond_broadcast (pthread_cond_t *cond);
       // Both return: 0 if OK, error number on failure
     #+end_src

     - Example
       #+caption: Figure 11.15 Using a condition variable
       #+include: "Chapter11/fig11.15.c" src c
**** DONE 11.6.7 Spin Locks
     CLOSED: [2019-11-10 Sun 16:15]
     #+begin_quote
     A spin lock is like a mutex, except that *instead of blocking* a process by sleeping, the process is blocked by busy-waiting (spinning) until the lock can be acquired

     use for short periods of times
     #+end_quote

     #+begin_src c
       #include <pthread.h>
       int pthread_spin_init(pthread_spinlock_t *lock, int pshared);
       int pthread_spin_destroy(pthread_spinlock_t *lock);
       // Both return: 0 if OK, error number on failure
     #+end_src
     * *PTHREAD_PROCESS_SHARED*: the spin lock can be acquired by threads that have access to the lock's underlying memory
     * *PTHREAD_PROCESS_PRIVATE*: the spin lock can be accessed by only from threads within the process that initialized it.


     ~pthread_spin_trylock~ doesn't spin,
     #+begin_src c
       #include <pthread.h>
       int pthread_spin_lock(pthread_spinlock_t *lock);
       int pthread_spin_trylock(pthread_spinlock_t *lock);
       int pthread_spin_unlock(pthread_spinlock_t *lock);
       // All return: 0 if OK, error number on failure
     #+end_src
     If either pthread_spin_lock or pthread_spin_trylock returns 0, then the spin lock is locked

**** DONE 11.6.8 Barriers
     CLOSED: [2019-11-14 Thu 20:57]
     *Mac OSX doesn't implemented yet, but we can implemente it by pthread_cond and pthread_mutex*
     coordinate multiple threads working in parallel.
     #+begin_src c
       #include <pthread.h>
       int pthread_barrier_init(pthread_barrier_t *restrict barrier,
                                const pthread_barrierattr_t *restrict attr,
                                unsigned int count);
       int pthread_barrier_destroy(pthread_barrier_t *barrier);
       // Both return: 0 if OK, error number on failure
     #+end_src
     *count* refers to the number of threads that must call ~pthread_barrier_wait()~ (includes the calling in process)

     ~pthread_barrier_wait~ indicates a thread is done with its work and is ready to wait for all the other threads to catch up .
     #+begin_src c
       #include <pthread.h>
       int pthread_barrier_wait(pthread_barrier_t *barrier);
       // Returns: 0 or PTHREAD_BARRIER_SERIAL_THREAD if OK, error number on failure
     #+end_src
     calling ~pthread_barrier_wait~ is put to sleep if barrier count is not yet satisfied.

     - Example
       #+caption: Figure 11.16 Using a barrier
       #+include: "Chapter11/fig11.16.c" src c
*** DONE 11.7 Summary
    CLOSED: [2019-11-15 Fri 00:29]
    - Exercises
      - 11.1
        #+include: "Chapter11/ex11.1.c" src c
      - 11.2
        #+begin_quote
        write-mode lock on the whole list while the ID is changing.

        the thread ID between ~job_find~ and ~job_remove~ maybe changed

        to solve this problem, add another mutex in struct job
        #+end_quote
      - 11.3
        #+include: "Chapter11/ex11.3.c" src c
        1. rwlock change to condition lock, and need additional mutex lock
        2. data structure for each thread OR
        3. if lock the whole list, the other jobs have to wait, it is the waste of time
      - 11.4
        #+begin_quote
        It depends on the circumstances. In general, both can be correct, but each alternative has drawbacks. In the first sequence, the waiting threads will be scheduled to run after we call pthread_cond_broadcast. If the program is running on a multiprocessor, some threads will run and immediately block because we are still holding the mutex (recall that pthread_cond_wait returns with the mutex held). In the second sequence, a running thread can acquire the mutex between steps 3 and 4, invalidate the condition, and release the mutex. Then, when we call pthread_cond_broadcast, the condition will no longer be true, and the threads will run needlessly. This is why the awakened threads must recheck the condition and not assume that it is true merely because pthread_cond_wait returned.
        #+end_quote
      - 11.5
        pthread_cond && counter
        #+include: "Chapter11/ex11.5.c" src c
** TODO Chapter 12. Thread Control [9/11]
*** DONE 12.1 Introduction
    CLOSED: [2019-11-14 Thu 22:39]
*** DONE 12.2 Thread Limits
    CLOSED: [2019-11-15 Fri 08:42]
    #+caption: Figure 12.1 Thread limits and /name/ arguments to ~sysconf~
    | Name of limit                 | Description                                   | /name/ argument                  |
    |-------------------------------+-----------------------------------------------+----------------------------------|
    | PTHREAD_DESTRUCTOR_ITERATIONS | maximum number of times an implemetation will | _SC_THREAD_DESTRUCTOR_ITERATIONS |
    |                               | try to destroy the thread-specific data       |                                  |
    |                               | when a thread exits (Section 12.6)            |                                  |
    | PTHREAD_KEYS_MAX              | maximum number of keys that can be created    | _SC_THREAD_KEYS_MAX              |
    |                               | by a process (Section 12.6)                   |                                  |
    | PTHREAD_STACK_MIN             | minimum number of bytes that can be used      | _SC_THREAD_STACK_MIN             |
    |                               | for a thread's stack (Section by 12.3)        |                                  |
    | PTHREAD_STACK_MAX             | maximum number of threads that can be created | _SC_THREAD_STACK_MAX             |
    |                               | in a process (Section 12.3)                   |                                  |
*** DONE 12.3 Thread Attributes
    CLOSED: [2019-11-15 Fri 16:45]
    #+begin_quote
    1. Each object is associated with its own type of attribute object (threads with thread attributes, mutexes with mutex attributes, and so on).

    2. An initialization function exists to set the attributes to their default values.

    3. Another function exists to destroy the attributes object.

    4. Each attribute has a function to get the value of the attribute from the attribute object.

    5. Each attribute has a function to set the value of the attribute.
    #+end_quote

    #+begin_src c
      #include <pthread.h>
      int pthread_attr_init(pthread_attr_t *attr);
      int pthread_attr_destroy(pthread_attr_t *attr);
      // Both return: 0 if OK, error number on failure
    #+end_src

    attributes:
    #+caption: Figure 12.3 POSIX.1 thread attributes
    | Name          | Description                                       |
    |---------------+---------------------------------------------------|
    | /detachstate/ | detached threada attribute                        |
    | /guardsize/   | guard buffer size in bytes at end of thread stack |
    | /stackaddr/   | lowest address of thread stack                    |
    | /stacksize/   | minimum size in bytes of thread stack             |

    detachstate:
    #+begin_src c
      #include <pthread.h>
      int pthread_attr_getdetachstate(const ptrhead_attr_t *restrict attr,
                                      int *detachstate);
      int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
      // Both return: 0 if OK, error number on failure
    #+end_src
    ~PTHREAD_CREATE_DETACHED~ or ~PTHREAD_CREATE_JOINABLE~

    - Example
      #+caption: Figure 12.4 Creating a thread in the detached state
      #+include: "Chapter12/fig12.4.c" src c

    stack:
    #+begin_src c
      #include <pthread.h>
      int pthread_attr_getstack(const pthread_attr_t *restrict attr,
                                void **restrict stackattr,
                                size_t *restrict stacksize);
      int pthread_attr_setstack(pthread_attr_t *attr,
                                void *stackaddr, size_t stacksize);
      // Both return: 0 if OK, error number on failure
    #+end_src

    guardsize:
    #+begin_src c
      #include <pthread.h>
      int pthread_attr_getguardsize(const pthread_attr_t *restrict attr,
                                    size_t *restrict guardsize);
      int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);
      // Both return: 0 if OK, error number on failure
    #+end_src

    #+begin_quote
    Threads have other attributes not represented by the pthread_attr_t structure: the cancelability state and the cancelability type.
    #+end_quote

*** DONE 12.4 Synchronization Attributes [4/4]
    CLOSED: [2019-11-17 Sun 16:21]
**** DONE 12.4.1 Mutex Attributes
     CLOSED: [2019-11-15 Fri 18:07]
     #+begin_src c
       #include <pthread.h>
       int pthread_mutexattr_init(pthread_mutexattr_t *attr);
       int pthread_mutexattr_destroy(pthread_mutexattr *attr);
       // Both return: 0 if OK, error number on failure
     #+end_src

     #+begin_src c
       #include <pthread.h>
       int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict attr,
                                       int *restrict pshared);
       int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr,
                                       int pshared);
       // Both return: 0 if OK, error number on failure
     #+end_src
     default: ~PTHREAD_PROCESS_PRIVATE~
     #+begin_quote
     multiple threads can access the same synchronization object
     #+end_quote
     other: ~PTHREAD_PROCESS_SHARED~
     #+begin_quote
     a mutex allocated from a memory extent shared between multiple processes may be used for synchronization by those processes.
     #+end_quote

     #+begin_src c
       #include <pthread.h>
       int pthread_mutexattr_getrobust(const pthread_mutexattr_t *restrict attr,
                                       int *restrict robust);
       int pthread_mutexattr_setrobust(pthread_mutexattr_t *attr, int robust);
       // Both return: 0 if OK, error number on failure
     #+end_src
     default: ~PTHREAD_MUTEX_STALLED~
     #+begin_quote
     use of the mutex can result in undefined behavior, and applications waiting for it to be unlocked are effectively "stalled".
     #+end_quote
     other:   ~PTHREAD_MUTEX_ROBUST~
     #+begin_quote
     This value will cause a thread blocked in a call to pthread_mutex_lock to acquire the lock when another process holding the lock terminates without first unlocking it, but the return value from pthread_mutex_lock is EOWNERDEAD instead of 0.
     #+end_quote

     *Using robust mutexes has to check for three return values instead of two*:
     * success with no recovery
     * success but recovery needj
     * failure


     for application can't be recovered to indicate that the state associated with the mutex is consistent before unlocking the mutex.
     #+begin_src c
       #include <pthread.h>
       int pthread_mutex_consistent(pthread_mutex_t *mutex);
       // Returns: 0 if OK, error number on failure
     #+end_src
     #+caption: mutex types
     | type                     | description                                                          |
     |--------------------------+----------------------------------------------------------------------|
     | PTHREAD_MUTEX_NORMAL     | doesn't do any special error checking or deadlock detection          |
     | PTHREAD_MUTEX_ERRORCHECK | provides error checking                                              |
     | PTHREAD_MUTEX_RECURSIVE  | allow the same thread to lock multiple times without first unlocking |
     | PTHREAD_MUTEX_DEFAULT    | prividing default characteristics and behavior.                      |

     #+caption: Figure 12.5 Mutex type behavior
     | Mutex type               | Relock without unlock? | Unlock when not owned? | Unlock when unlocked? |
     |--------------------------+------------------------+------------------------+-----------------------|
     | PTHREAD_MUTEX_NORMAL     | deadlock               | undefined              | undefined             |
     | PTHREAD_MUTEX_ERRORCHECK | returns error          | returns error          | returns error         |
     | PTHREAD_MUTEX_RECURSIVE  | allowed                | returns error          | returns error         |
     | PTHREAD_MUTEX_DEFAULT    | undefined              | undefined              | undefined             |

     #+begin_src c
       #include <pthread.h>
       int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict attr,
                                     int *restrict type);
       int pthread_mutexattr_settype(pthread_mutexattr_t *restrict attr, int type);
       // Both return: 0 if OK, error number on failure
     #+end_src

     #+begin_quote
     If a recursive mutex is locked multiple times and used in a call to pthread_cond_wait, the condition can never be satisfied, because the unlock done by pthread_cond_wait doesn’t release the mutex.

     should be used only when no other solution is possible.
     #+end_quote

     - Example
       #+caption: Figure 12.8 Using a recursive mutex
       #+include: "Chapter12/fig12.8.c" src c
**** DONE 12.4.2 Reader-Writer Lock Attributes
     CLOSED: [2019-11-17 Sun 15:55]
     #+begin_src c
       #include <pthread.h>
       int pthread_rwlockattr_init(pthread_rwlockattr_t *attr);
       int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr);

       int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict attr,
                                         int *restirct pshared);
       int pthread_rwlockattr_setpshared(const pthread_rwlockattr_t *restrict attr,
                                         int pshared);
       // Both return: 0 if OK, error number on failure
     #+end_src
**** DONE 12.4.3 Condition Variable Attributes
     CLOSED: [2019-11-17 Sun 16:15]
     #+begin_src c
       #include <pthread.h>
       int pthread_condattr_init(pthread_condattr_t *attr);
       int pthread_condattr_destroy(pthread_condattr_t *attr);

       int pthread_condattr_getpshared(pthread_condattr_t const *restrict attr,
                                       int *restrict pshared);
       int pthread_condattr_setpshared(pthread_condattr_t *attr,
                                       int pshared); ;

       int pthread_condattr_getclock(const pthread_condattr_t *restrict attr,
                                     clockid_t *restrict clock_id);
       int pthread_condattr_setclock(pthread_condattr_t *attr,
                                     clockid_t clock_id);
       // Both return: 0 if OK, error number on failure
     #+end_src
**** DONE 12.4.4 Barrier Attributes
     CLOSED: [2019-11-17 Sun 16:21]
     #+begin_src c
       #include <pthread.h>
       int pthread_barrierattr_init(pthread_barrierattr_t *attr);
       int pthread_barrierattr_destroy(pthread_barrierattr_t *attr);

       int pthread_barrierattr_getpshared(const pthread_barrierattr_t *restrict attr,
                                          int *restrict pshared);
       int pthread_barrierattr_setpshared(const pthread_barrierattr_t *attr,
                                          int pshared);
       // Both return: 0 if OK, error number on failure
     #+end_src
*** DONE 12.5 Reentrancy
    CLOSED: [2019-11-17 Sun 17:13]
    #+begin_quote
    If a function can be safely called by multiple threads at the same time, we say that the function is thread-safe.

    /thread-safe/ version of functions with an _r appended at the end of its name
    #+end_quote

    lock associated with a given FILE object
    #+begin_src c
      #include <sstdio.h>
      int ftrylockfile(FILE *fp);
      // Returns: 0 if OK, nonzero if lock can't be acquired
      void flockfile(FILE *fp);
      void funlockfile(FILE *fp);
    #+end_src
    I/O routines might be implemented to be thread-safe, but locking applications is still useful


    lock associated with character-based standard I/O
    #+begin_src c
      #include <pthread.h>
      int getchar_unlcoked(void);
      int getc_unlcoked(FILE *fp);
      // Both return: the next character if OK, EOF on the end of file or error

      int putchar_unlocked(int c);
      int putc_unlcoked(int c, FILE *fp);
      // Both return: c if OK, EOF on error
    #+end_src
    #+begin_quote
    *These four functions should not be called unless they are surrounded by calls to flockfile (or ftrylockfile) and funlockfile*
    #+end_quote

    - Example
      #+caption: Figure 12.11 A nonreentrant version of getenv
      #+include: "Chapter12/fig12.11.c" src c

      #+caption: Figure 12.12 a reentrant (thread-safe) version of getenv
      #+include: "Chapter12/fig12.12.c" src c
*** DONE 12.6 Thread-Specific Data
    CLOSED: [2019-11-17 Sun 21:20]
    #+begin_quote
    Thread-specific data, also known as thread-private data, is a mechanism for storing and finding data associated with a particular thread

    The reasons to prevent sharing process data and attributes
    - First, sometimes we need to maintain data on a per-thread basis.
    - The second reason for thread-private data is to provide a mechanism for adapting process-based interfaces to a multithreaded environment.
    #+end_quote

    crate a /key/ to gain acess to with the thread-specific data
    #+begin_src c
      #include <pthread.h>
      int pthread_key_create(pthread_key_t *keyp, void (*destructor)(void*));
      // Returns: 0 if OK, error number on failure
    #+end_src
    break the association of a key with the thread-specific data
    #+begin_src c
      #include <pthread.h>
      int pthread_key_delete(pthread_key_t key);
    #+end_src
    #+begin_quote
    *calling pthread_key_delete will not invoke the destructor function. To free a key:*
    ensure a key we allocated doesn't change because of a race during initialization. Code like the following can result in two threads both calling ~pthread_key_create~:
    #+begin_src c
      void destructor(void *);
      pthread_key_t key;
      int init_done = 0;

      int threadfunc(void *arg) {
        if (!init_done) {
          init_done = 1;
          err = pthread_key_create(&key, destructor);
        }
      }
    #+end_src

    The proper way to create a key without a race is as follows:
    #+begin_src c
      void destructor(void *);

      pthread_key_t key;
      pthread_once_t init_done = PTHREAD_ONCE_INIT;

      void thread_init(void) {
        err = pthread_key_create(&key, destructor);
      }

      int threadfunc (void *arg) {
        pthread_once(&init_done, thread_init);
      }
    #+end_src
    #+end_quote

    - Example
      #+caption: Figure 12.13 A thread-safe, compatible version of getenv
      #+include: "Chapter12/fig12.13.c" src c
*** DONE 12.7 Cancel Options
    CLOSED: [2019-11-18 Mon 09:49]
    #+begin_quote
    The /cancelability state/ attribute can be either PTHREAD_CANCEL_ENABLE or PTHREAD_CANCEL_DISABLE.
    #+end_quote
    #+begin_src c
      #include <pthread.h>
      int pthread_setcancelstate(int state, int* oldstate);
      // Returns: 0 if OK, error number on failure
    #+end_src

    #+begin_quote
    a call to pthread_cancel doesn’t wait for a thread to terminate. In the default case, a thread will continue to execute after a cancellation request is made until the thread reaches a cancellation point.


    When the state is set to PTHREAD_CANCEL_DISABLE, a call to pthread_cancel will not kill the thread. Instead, the cancellation request remains pending for the thread. When the state is enabled again, the thread will act on any pending cancellation requests at the next cancellation point.
    #+end_quote

    add you own cancellation points
    #+begin_src c
      #include <pthread.h>
      void pthread_testcancel(void);
    #+end_src
    Cancel the pending and enbaled cancellation request, no effect when cancellation is disabled.

    change the cancellation type
    #+begin_src c
      #include <pthread.h>
      int pthread_setcanceltype(int type, int *oldtype);
      // Returns: 0 if OK, error number on failure
    #+end_src
    type: PTHREAD_CANCEL_DEFERRED, PTHREAD_CANCEL_ASYNCHRONOUS
*** DONE 12.8 Threads and Signals
    CLOSED: [2019-11-27 Wed 00:51]
    function like ~sigprocmask~, but works with threads and returns error number instead:
    #+begin_src c
      #include <signal.h>
      int pthread_sigmask(int how, const sigset_t *restrict set,
                          sigset_t *restrict oset);
      // Returns: 0 if OK, error number on failure
    #+end_src
    how values:
    * SIG_BLOCK
    * SIG_SETMASK
    * SIG_UNBLOCK

      wait one or more signals:
    #+begin_src c
      #include <signal.h>
      int sigwait(const siget_t *restrict set, int *restrict signop);
      // Returns: 0 if OK, error number on failure
    #+end_src

    function like ~kill~:
    #+begin_src c
      #include <signal.h>
      int pthread_kill(pthread_t thread, int signo);
      // Returns: 0 if OK, error number on failure
    #+end_src

    - Example:
      #+caption: Figure 12.16 Synchronous signal handling
      #+include: "Chapter12/fig12.16.c" src c
*** DONE 12.9 Threads and fork
    CLOSED: [2019-11-28 Thu 01:33]
    #+begin_src c
      #include <pthread.h>
      int pthread_atfork(void (*prepare)(void), void (*parent)(void),
                         void (*child)(void));
      // Returns: 0 if OK, error number on failure
    #+end_src

    * *prepare* called before ~fork~ creates the child process
    * *parent* called in parent after ~fork~ has created the child but before returned
    * *child* called in child before returning


    *the child will get a copy of all locks that the parent defined, but in new memory*
    1. The parent acquired all its locks.
    2. The child acquired all its locks.
    3. The parent released its locks.
    4. The child relased its locks.


    - Example:
      #+caption: Figure 12.17 pthread_atfork example
      #+include: "Chapter12/fig12.17.c" src c


    *drawbacks*:
    #+begin_quote
    * no good way to reinitialize the state for more complex synchronization like conditioon and barriers.
    * some implementations of error-checking mutexes will generate errors when the child fork handler tries to unlock a mutex that was locked by the parent
    * recursive mutexes can't be cleand up in the child fork handler, because there is no way to determine the number of times one has been locked
    * if child process are allowed to call only async-singal safe functions, then the child fork handler shouldn't even be able to clean up synchronization objects, because none of the functions are used to manipulate them are async-signal safe.
    * if an application calls fork in a signal handler(which is legal, because fork is async-signal safe), then the fork handlers registered by ~pthread_atfork~ can only async-signal safe functions, or else the results are undefined.
    #+end_quote

*** DONE 12.10 Threads and I/O
    CLOSED: [2019-11-28 Thu 13:31]
    use ~pread/pwrite~ in Chapter 3 to solve I/O at different record
*** TODO 12.11 Summary

** TODO Chapter 13. Daemon Processes [0/0]
** TODO Chapter 14. Advanced I/O [4/9]
*** DONE 14.1 Introduction
*** DONE 14.2 Nonblocking I/O
    slow system calls can block forever. include:
    * reads if data isn't present with certain file types
    * writes if data isn't present with certain file types
    * open conditions
    * mandatory record locking
    * ~ioctl~ options
    * IPC


    two way to specify nonblocking I/O:
    1. ~open~ to get the descriptor, specify ~O_NONBLOCK~ flag
    2. call ~fcntl~ to trun on the ~O_NONBLOCK~ if already open.


    - Example \\
      #+caption: Figure 14.1 Large nonblocking write
      #+include: "Chapter14/write.c" src c
*** DONE 14.3 Record Locking
    Record locking is the term normally used to describe the ability of a process to prevent other processes from modifying a region of a file while the first process is reading or modifying that portion of the file
    - 1. History
    - 2. ~fcntl~ Record Locking
      #+begin_src sh
        man 2 fcntl
      #+end_src


    - Example - Deadlock \\
      #+caption: Figure 14.7 Example of deadlock detection
      #+include: "Chapter14/deadlock.c" src c

    - Advisory versus Mandatory Locking
      - Example \\
        #+caption: Figure 14.12 Determine whether mandatory locking is supported
        #+include: "Chapter14/mandatory.c" src c
*** TODO 14.4 I/O Multiplexing
**** TODO 14.4.1 ~select~ and ~pselect~ Functions
**** TODO 14.4.2 ~poll~ Function
*** TODO 14.5 Asynchronous I/O
**** TODO 14.5.1 System V Asynchronous I/O
**** TODO 14.5.2 BSD Asynchronous I/O
**** TODO 14.5.3 POSIX Asynchronous I/O
*** TODO 14.6 ~readv~ and ~writev~ Functions
*** TODO 14.7 ~readn~ and ~writen~ Functions
*** DONE 14.8 Memory-Mapped I/O
    - Example
      #+caption: Figure 14.27 Copy a file using memory-mapped I/O
      #+include: "Chapter14/mcopy2.c" src c
*** TODO 14.9 Summary
** TODO Chapter 15. Interprocess Communication [0/16]
*** TODO 15.1 Introduction
*** TODO 15.2 Pipes
*** TODO 15.3 ~popen~ and ~pclose~ Functions
*** TODO 15.4 Coprocesses
*** TODO 15.5 FIFOs
*** TODO 15.6 XSI IPC
*** TODO 15.6.1 Identifiers and Keys
*** TODO 15.6.2 Permission Structure
*** TODO 15.6.3 Configuration Limits
*** TODO 15.6.4 Advantages and Disadvantages
*** TODO 15.7 Message Queues
*** TODO 15.8 Semaphores
*** TODO 15.9 Shared Memory
*** TODO 15.10 POSIX Semaphores
*** TODO 15.11 Client-Server Properties
*** TODO 15.12 Summary
** TODO Chapter 16. Network IPC: Sockets [0/9]
*** TODO 16.1 Introduction
*** TODO 16.2 Socket Descriptors
*** TODO 16.3 Addressing
**** TODO 16.3.1 Byte Ordering
**** TODO 16.3.2 Address Formats
**** TODO 16.3.3 Address Lookup
**** TODO 16.3.4 Associating Addresses with Sockets
*** TODO 16.4 Connection Establishment
*** TODO 16.5 Data Transfer
*** TODO 16.6 Socket Options
*** TODO 16.7 Out-of-Band Data
*** TODO 16.8 Nonblocking and Asynchronous I/O
*** TODO 16.9 Summary
** TODO Chapter 17. Advanced IPC [2/7]
*** TODO 17.1 Introduction
*** DONE 17.2 UNIX Domain Sockets
    - Example -- Polling XSI Message Queues with the Help of UNIX Domain Sockets
      #+caption: Figure 17.3 Poll for XSI Messsages using UNIX domain sockets
      #+include: "Chapter17/pollmsg.c" src c

      #+caption: Figure 17.4 Post a message to XSI message queue
      #+include: "Chapter17/sendmsg.c" src c
**** DONE 17.2.1 Naming UNIX Domain Sockets
     - Example \\
       #+caption: Figure 17.5 Binding an address to a UNIX domain socket
       #+include: "Chapter17/bindunix.c" src c
*** DONE 17.3 Unique Connections
    develop three functions can be used to create unique connections between unrelated processes running on same machine:
    #+begin_src c
      int serv_listen(const char *name);            // Returns: file descriptor to listen on if OK, negative value on error
      int serv_accept(int listenfd, uid_t *uidptr); // Returns: new file descriptor if OK, negative value on Error
      int cli_conn(const char *name);               // Returns: file descriptor if OK, negative value on error
    #+end_src


    #+begin_src c
      #include "apue.h"
      #include <errno.h>
      #include <sys/socket.h>
      #include <sys/un.h>

      #define QLEN 10

      /*
       ,* Create a server endpoint of a connection.
       ,* Returns fd if all OK, <0 on error.
       ,*/
      int serv_listen(const char *name)
      {
        int                fd, len, err, rval;
        struct sockaddr_un un;

        if (strlen(name) >= sizeof(un.sun_path)) {
          errno = ENAMETOOLONG;
          return (-1);
        }

        /* create a UNIX domain stream socket */
        if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
          return (-2);
        }

        /* in case it already exists */
        unlink(name);

        /* fill in socket address structure */
        memset(&un, 0, sizeof(un));
        un.sun_family = AF_UNIX;
        strcpy(un.sun_path, name);
        len = offsetof(struct sockaddr_un, sun_path) + strlen(name);

        /* bind the name to the descriptor */
        if (bind(fd, (struct sockaddr *)&un, len) < 0) {
          rval = -3;
          goto errout;
        }

        if (listen(fd, QLEN) < 0) {
          /* tell kernel we're a server */
          rval = -4;
          goto errout;
        }

        return (fd);

       errout:
        err = errno;
        close(fd);
        errno = err;
        return (rval);
      }
    #+end_src
    #+begin_center
    Figure 17.8 The ~serv_listen~ function
    #+end_center


    #+begin_src c
      #include "apue.h"
      #include <errno.h>
      #include <sys/socket.h>
      #include <sys/un.h>
      #include <time.h>

      #define STALE 30 /* client's name can't be older than this (sec) */

      /**********************************************************/
      /* Wait for a client connection to arrive, and accept it. */
      /* We also obtain the client's user ID from the pathname  */
      /* that it must bind before calling us.                   */
      /* Returns new fd if all OK, <0 on error                  */
      /**********************************************************/
      int serv_accept(int listenfd, uid_t *uidptr)
      {
        int                clifd, err, rval;
        socklen_t          len;
        time_t             staletime;
        struct sockaddr_un un;
        struct stat        statbuf;
        char *             name;

        /* allocate enough space for longest name plus terminating null */
        if ((name = malloc(sizeof(un.sun_path) + 1))) {
          return (-1);
        }
        len = sizeof(un);
        if ((clifd = accept(listenfd, (struct sockaddr *)&un, &len)) < 0) {
          free(name);
          return (-2);
        }

        /* obtain the client't uid from its calling address */
        /* len of pathname */
        len -= offsetof(struct sockaddr_un, sun_path);
        memcpy(name, un.sun_path, len);
        /* null terminate */
        name[len] = 0;
        if (stat(name, &statbuf) < 0) {
          rval = -3;
          goto errout;
        }

      #ifdef S_ISSOCK
        if (S_ISSOCK(statbuf.st_mode) == 0) {
          /* not a socket */
          rval = -4;
          goto errout;
        }
      #endif

        if ((statbuf.st_mode & (S_IRWXG | S_IRWXO)) ||
            (statbuf.st_mode & S_IRWXU) != S_IRWXU) {
          /* is not rwx------ */
          rval = -5;
          goto errout;
        }

        staletime = time(NULL) - STALE;
        if (statbuf.st_atime < staletime ||
            statbuf.st_ctime < staletime ||
            statbuf.st_mtime < staletime) {
          /* i-node is too old */;
          rval = -6;
          goto errout;
        }

        if (uidptr != NULL) {
          /* return uid of caller */
          ,*uidptr = statbuf.st_uid;
        }
        unlink(name);
        free(name);
        return (clifd);

       errout:
        err = errno;
        close(clifd);
        free(name);
        errno = err;
        return (rval);
      }
    #+end_src
    #+begin_center
    Figure 17.9 The ~serv_accept~ function
    #+end_center
    #+caption: Figure 17.10 The ~cli_conn~ function
    #+include: "Chapter17/cli_conn.c" src c
*** TODO 17.4 Passing File Descriptors
*** TODO 17.5 An Open Server, Version 1
*** TODO 17.6 An Open Server, Version 2
*** TODO 17.7 Summary
** TODO Chapter 18. Terminal I/O [0/0]
** TODO Chapter 19. Pseudo Terminals [0/0]
** TODO Chapter 20. A Database Library [0/0]
** TODO Chapter 21. Communication with a Network Printer [0/0]

* Footnotes

[fn:1] ~signalstack~
